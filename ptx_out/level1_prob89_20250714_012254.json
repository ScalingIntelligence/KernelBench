{
  "correct": false,
  "grid": 128,
  "block": 256,
  "llm_out": "```ptx\n.version 7.0\n.target sm_35\n.address_size 64\n\n.visible .entry my_kernel(\n    .param .u64 in_ptr,\n    .param .u64 out_ptr\n)\n{\n    .reg .pred %p<3>;\n    .reg .b32  %r<7>;\n    .reg .b64  %rd<11>;\n    .reg .f32  %f<3>;\n\n    // Load pointers\n    ld.param.u64 %rd1, [in_ptr];\n    ld.param.u64 %rd2, [out_ptr];\n\n    // row = blockIdx.x * blockDim.x + threadIdx.x\n    mov.u32      %r1, %ctaid.x;\n    mov.u32      %r2, %ntid.x;\n    mov.u32      %r3, %tid.x;\n    mad.lo.u32   %r0, %r1, %r2, %r3;\n\n    // if row >= 32768 return\n    setp.ge.u32  %p0, %r0, 32768;\n    @%p0 bra     END;\n\n    // Compute byte offset: row * 32768 * sizeof(float)\n    mul.wide.u32 %rd3, %r0, 32768;\n    shl.b64      %rd3, %rd3, 2;\n\n    add.u64      %rd4, %rd1, %rd3;   // input row base\n    add.u64      %rd5, %rd2, %rd3;   // output row base\n\n    // Initialize running sum\n    mov.f32      %f0, 0f00000000;\n    mov.u32      %r4, 0;\n\nLOOP:\n    setp.ge.u32  %p1, %r4, 32768;\n    @%p1 bra     END;\n\n    // Load element\n    mul.wide.u32 %rd6, %r4, 4;\n    add.u64      %rd7, %rd4, %rd6;\n    ld.global.f32 %f1, [%rd7];\n\n    // Accumulate and store\n    add.f32      %f0, %f0, %f1;\n    add.u64      %rd8, %rd5, %rd6;\n    st.global.f32 [%rd8], %f0;\n\n    // Next column\n    add.u32      %r4, %r4, 1;\n    bra          LOOP;\n\nEND:\n    ret;\n}\n```\nLAUNCH = (128, 256)"
}