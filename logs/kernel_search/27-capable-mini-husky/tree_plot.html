<!doctype html>
<html lang="en"> 
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      id="p5scripttag"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
      integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <script>
      const bgCol = "#F2F0E7";
const accentCol = "#fd4578";

hljs.initHighlightingOnLoad();

const updateTargetDims = () => {
  // width is max-width of `.contentContainer` - its padding
  // return [min(windowWidth, 900 - 80), 700]
  return [windowWidth * (1 / 2), windowHeight];
};

const setCodeAndPlan = (code, plan) => {
  const codeElm = document.getElementById("code");
  if (codeElm) {
    // codeElm.innerText = code;
    codeElm.innerHTML = hljs.highlight(code, { language: "python" }).value;
  }

  const planElm = document.getElementById("plan");
  if (planElm) {
    // planElm.innerText = plan.trim();
    planElm.innerHTML = hljs.highlight(plan, { language: "plaintext" }).value;
  }
};

windowResized = () => {
  resizeCanvas(...updateTargetDims());
  awaitingPostResizeOps = true;
};

const animEase = (t) => 1 - (1 - Math.min(t, 1.0)) ** 5;

// ---- global constants ----

const globalAnimSpeed = 1.1;
const scaleFactor = 0.57;

// ---- global vars ----

let globalTime = 0;
let manualSelection = false;

let currentElemInd = 0;

let treeStructData = {"edges": [[3, 4]], "layout": [[0.0, 0.0], [0.3333333333333333, 0.0], [0.6666666666666666, 0.0], [1.0, 0.0], [1.0, 1.0]], "plan": ["", "", "Optimization plan: 1.  The primary computational bottleneck in the given model\nis the `torch.matmul` operation. 2.  We will replace this operation with a\ncustom CUDA kernel implementing tiled matrix multiplication. 3.  The kernel will\nleverage shared memory to cache blocks of input matrices A and B, minimizing\nglobal memory accesses and improving data locality. 4.  A `TILE_SIZE` of 32 will\nbe used for thread blocks and shared memory tiles, balancing parallelism and\nshared memory usage for `fp32` precision. 5.  The implementation will prioritize\ncorrectness and basic optimization by ensuring coalesced memory access patterns\nand proper synchronization within the kernel.", "My optimization plan focuses on replacing the `torch.matmul` operation with a\ncustom CUDA kernel. I will implement a tiled matrix multiplication algorithm,\nwhich is a standard and effective approach for GPUs. Each thread block will be\nresponsible for computing a tile of the output matrix `C`. Threads within a\nblock will cooperatively load sub-matrices of `A` and `B` into shared memory,\nthen perform the dot product using these shared memory tiles to minimize global\nmemory accesses and improve data reuse. This strategy improves memory coalescing\nand reduces overall memory traffic.", "My optimization plan focuses on replacing the `torch.matmul` operation with a\ncustom CUDA kernel. I will implement a tiled matrix multiplication algorithm.\nEach thread block will be responsible for computing a tile of the output matrix\n`C`. Threads within a block will cooperatively load sub-matrices of `A` and `B`\ninto shared memory, then perform the dot product using these shared memory tiles\nto minimize global memory accesses and improve data reuse. This strategy\nimproves memory coalescing and reduces overall memory traffic. The compilation\nerror was likely due to the CUDA compiler not correctly interpreting the\n`#define TILE_SIZE` within the `cuda_source` string in the `load_inline`\nenvironment. To fix this, `TILE_SIZE` is now passed explicitly as a compilation\nflag (`-DTILE_SIZE=32`) via `extra_cuda_cflags` to ensure it's properly defined\nfor the CUDA kernel."], "code": ["import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom CUDA kernel with tiled shared memory access.\n    \"\"\"\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Define BLOCK_SIZE for the tiled matrix multiplication kernel.\n        # This value can be tuned for optimal performance.\n        self.BLOCK_SIZE = 32\n\n        # CUDA kernel source code for tiled matrix multiplication\n        # Uses shared memory to reduce global memory traffic and improve data reuse.\n        cuda_source_template = \"\"\"\n        #define BLOCK_SIZE {BLOCK_SIZE}\n\n        __global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n            // Calculate the global row and column of the C element this thread is responsible for.\n            int global_row = blockIdx.y * BLOCK_SIZE + threadIdx.y;\n            int global_col = blockIdx.x * BLOCK_SIZE + threadIdx.x;\n\n            // Shared memory for tiles of A and B.\n            // These tiles will hold BLOCK_SIZE x BLOCK_SIZE sub-matrices.\n            __shared__ float A_shared[BLOCK_SIZE][BLOCK_SIZE];\n            __shared__ float B_shared[BLOCK_SIZE][BLOCK_SIZE];\n\n            float acc = 0.0f; // Accumulator for C[global_row][global_col]\n\n            // Iterate over the tiles along the K dimension.\n            // N / BLOCK_SIZE gives the number of tiles needed to cover the K dimension.\n            // Using ceiling division to handle cases where N is not a multiple of BLOCK_SIZE.\n            int num_tiles = (N + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n            for (int tile_k = 0; tile_k < num_tiles; ++tile_k) {\n                // Calculate the global indices for loading data into shared memory.\n                // Each thread loads one element into shared memory.\n\n                // For A_shared[threadIdx.y][threadIdx.x]:\n                // Source A element is at A[global_row][tile_k * BLOCK_SIZE + threadIdx.x]\n                int A_load_row = global_row;\n                int A_load_col = tile_k * BLOCK_SIZE + threadIdx.x;\n\n                // For B_shared[threadIdx.y][threadIdx.x]:\n                // Source B element is at B[tile_k * BLOCK_SIZE + threadIdx.y][global_col]\n                int B_load_row = tile_k * BLOCK_SIZE + threadIdx.y;\n                int B_load_col = global_col;\n\n                // Load elements from global memory into shared memory.\n                // Include boundary checks to handle tensor dimensions that are not multiples of BLOCK_SIZE.\n                if (A_load_row < N && A_load_col < N) {\n                    A_shared[threadIdx.y][threadIdx.x] = A[A_load_row * N + A_load_col];\n                } else {\n                    A_shared[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zero if out of bounds\n                }\n\n                if (B_load_row < N && B_load_col < N) {\n                    B_shared[threadIdx.y][threadIdx.x] = B[B_load_row * N + B_load_col];\n                } else {\n                    B_shared[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zero if out of bounds\n                }\n\n                // Synchronize all threads in the block.\n                // This ensures all shared memory loads are complete before computation begins.\n                __syncthreads();\n\n                // Perform the dot product of the loaded tiles.\n                // Each thread computes a partial sum for its C element.\n                for (int k_idx = 0; k_idx < BLOCK_SIZE; ++k_idx) {\n                    acc += A_shared[threadIdx.y][k_idx] * B_shared[k_idx][threadIdx.x];\n                }\n\n                // Synchronize all threads in the block again.\n                // This ensures all threads have finished using the current shared memory tiles\n                // before the next iteration loads new data, preventing race conditions.\n                __syncthreads();\n            }\n\n            // Store the final accumulated result to global memory, if within bounds.\n            if (global_row < N && global_col < N) {\n                C[global_row * N + global_col] = acc;\n            }\n        }\n        \"\"\"\n        # Compile the CUDA kernel using torch.utils.cpp_extension.load_inline\n        self.custom_matmul_module = load_inline(\n            name=\"custom_matmul_module\",\n            cuda_sources=[cuda_source_template.format(BLOCK_SIZE=self.BLOCK_SIZE)],\n            functions=[\"matmul_kernel\"],\n            verbose=False, # Set to True for verbose compilation output\n            with_cuda=True,\n        )\n        # Get the compiled kernel function\n        self.matmul_kernel = self.custom_matmul_module.matmul_kernel\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure inputs are on the CUDA device and have float32 precision.\n        if not A.is_cuda:\n            A = A.cuda()\n        if not B.is_cuda:\n            B = B.cuda()\n        if A.dtype != torch.float32:\n            A = A.float()\n        if B.dtype != torch.float32:\n            B = B.float()\n\n        N = A.size(0)\n        # Basic input validation for square matrices of the same dimension.\n        assert A.size(1) == N and B.size(0) == N and B.size(1) == N, \\\n            \"Input matrices must be square and have the same dimension N.\"\n\n        # Allocate the output tensor C on the same device as A and B.\n        C = torch.empty_like(A)\n\n        # Calculate grid and block dimensions for kernel launch.\n        # Grid dimensions: (ceil(N / BLOCK_SIZE), ceil(N / BLOCK_SIZE))\n        grid_dim_x = (N + self.BLOCK_SIZE - 1) // self.BLOCK_SIZE\n        grid_dim_y = (N + self.BLOCK_SIZE - 1) // self.BLOCK_SIZE\n        grid_dim = (grid_dim_x, grid_dim_y)\n\n        # Block dimensions: (BLOCK_SIZE, BLOCK_SIZE)\n        block_dim = (self.BLOCK_SIZE, self.BLOCK_SIZE)\n\n        # Launch the custom CUDA kernel.\n        # The kernel is called using the PyTorch extension's launch syntax:\n        # kernel_function[grid_dimensions, block_dimensions](kernel_arguments...)\n        self.matmul_kernel[grid_dim, block_dim](A, B, C, N)\n\n        return C", "The optimization plan focuses on replacing the `torch.matmul` operation with a custom CUDA kernel. I will implement a tiled matrix multiplication kernel that leverages shared memory to reduce global memory traffic and improve data reuse. Each thread block will compute a tile of the output matrix `C`, with threads within the block cooperatively loading sub-matrices of `A` and `B` into shared memory before performing local computations. The kernel will be compiled and integrated using `torch.utils.cpp_extension.load_inline`.\n\n```python\nimport torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# Define BLOCK_SIZE for the tiled matrix multiplication kernel.\n# A common choice is 32, which results in 32x32 = 1024 threads per block,\n# ensuring good occupancy and shared memory usage.\nBLOCK_SIZE = 32\n\n# CUDA kernel source code for a tiled matrix multiplication.\n# This kernel computes C = A * B for square matrices of size N.\n# BLOCK_SIZE is passed as a compile-time macro.\ncuda_source = f\"\"\"\n#include <torch/extension.h>\n#include <cuda_runtime.h>\n\n// BLOCK_SIZE is defined by extra_cuda_cflags during compilation.\n// Example: -DBLOCK_SIZE=32\n\n__global__ void matmul_kernel(float* C, const float* A, const float* B, int N) {\n    // Calculate the global row and column for the current thread.\n    // Each thread block computes a BLOCK_SIZE x BLOCK_SIZE tile of C.\n    // Each thread within the block computes one element of this tile.\n    int row = blockIdx.y * BLOCK_SIZE + threadIdx.y;\n    int col = blockIdx.x * BLOCK_SIZE + threadIdx.x;\n\n    // Accumulator for the C element computed by this thread.\n    float C_value = 0.0f;\n\n    // Shared memory for tiles of A and B.\n    // These tiles are loaded from global memory and reused by all threads\n    // within the block to reduce global memory accesses.\n    __shared__ float sA[BLOCK_SIZE][BLOCK_SIZE];\n    __shared__ float sB[BLOCK_SIZE][BLOCK_SIZE];\n\n    // Iterate over the K dimension (inner product).\n    // Each iteration loads a new pair of sub-matrices (tiles) of A and B\n    // into shared memory and performs a partial matrix multiplication.\n    int num_tiles = N / BLOCK_SIZE;\n    for (int tile_idx = 0; tile_idx < num_tiles; ++tile_idx) {\n        // Load the current tiles from global memory into shared memory.\n        // Each thread loads one element.\n        // Given N is a multiple of BLOCK_SIZE and inputs are square,\n        // explicit boundary checks (e.g., row < N) are not strictly needed\n        // for the problem's specific N, as all accesses will be in bounds.\n        sA[threadIdx.y][threadIdx.x] = A[row * N + (tile_idx * BLOCK_SIZE + threadIdx.x)];\n        sB[threadIdx.y][threadIdx.x] = B[(tile_idx * BLOCK_SIZE + threadIdx.y) * N + col];\n\n        // Synchronize all threads in the block. This ensures that all data\n        // for the current tiles (sA and sB) has been loaded into shared memory\n        // before any thread starts using it for computation.\n        __syncthreads();\n\n        // Perform the matrix multiplication for the current tiles in shared memory.\n        // The #pragma unroll hint encourages the compiler to unroll this loop\n        // for better instruction-level parallelism.\n        #pragma unroll\n        for (int k = 0; k < BLOCK_SIZE; ++k) {\n            C_value += sA[threadIdx.y][k] * sB[k][threadIdx.x];\n        }\n\n        // Synchronize all threads again. This ensures that all computations\n        // using the current shared memory tiles are complete before new tiles\n        // are loaded in the next iteration.\n        __syncthreads();\n    }\n\n    // Write the final accumulated result for this C element to global memory.\n    // No explicit boundary check needed here for the same reasons as above.\n    C[row * N + col] = C_value;\n}\n\n// C++ wrapper function to be called from Python.\n// It handles tensor checks, memory allocation, and kernel launch configuration.\ntorch::Tensor matmul_custom(const torch::Tensor& A, const torch::Tensor& B) {\n    // Input validation checks for dimensions, device, and data type.\n    TORCH_CHECK(A.dim() == 2 && B.dim() == 2, \"Inputs must be 2D matrices.\");\n    TORCH_CHECK(A.size(1) == B.size(0), \"Inner dimensions must match for matmul.\");\n    TORCH_CHECK(A.size(0) == A.size(1) && B.size(0) == B.size(1) && A.size(0) == B.size(0), \"Inputs must be square matrices of the same size N.\");\n    TORCH_CHECK(A.is_cuda() && B.is_cuda(), \"Inputs must be CUDA tensors.\");\n    TORCH_CHECK(A.dtype() == torch::kFloat32 && B.dtype() == torch::kFloat32, \"Inputs must be float32 tensors.\");\n\n    int N = A.size(0);\n    // This kernel assumes N is a multiple of BLOCK_SIZE for simplicity and efficiency.\n    TORCH_CHECK(N % BLOCK_SIZE == 0, \"N must be a multiple of BLOCK_SIZE for this kernel.\");\n\n    // Create the output tensor C on the same device and with the same options as input A.\n    auto C = torch::empty({N, N}, A.options());\n\n    // Configure grid and block dimensions for the kernel launch.\n    // Each block is BLOCK_SIZE x BLOCK_SIZE threads.\n    // The grid is (N/BLOCK_SIZE) x (N/BLOCK_SIZE) blocks.\n    dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE);\n    dim3 dimGrid(N / BLOCK_SIZE, N / BLOCK_SIZE);\n\n    // Launch the CUDA kernel.\n    matmul_kernel<<<dimGrid, dimBlock>>>(\n        C.data_ptr<float>(), // Pointer to output C data\n        A.data_ptr<float>(), // Pointer to input A data\n        B.data_ptr<float>(), // Pointer to input B data\n        N                    // Size of the square matrices\n    );\n\n    // Check for any CUDA errors that might have occurred during kernel execution.\n    cudaError_t err = cudaGetLastError();\n    if (err != cudaSuccess) {\n        fprintf(stderr, \"CUDA error: %s\\\\n\", cudaGetErrorString(err));\n    }\n\n    return C;\n}\n\"\"\"\n\n# C++ wrapper definition for the inline compilation.\n# This declares the `matmul_custom` function.\ncpp_source = \"\"\"\ntorch::Tensor matmul_custom(const torch::Tensor& A, const torch::Tensor& B);\n\"\"\"\n\n# Compile the CUDA kernel and expose the `matmul_custom` function to Python.\n# `extra_cuda_cflags` are used to define BLOCK_SIZE as a preprocessor macro\n# and set optimization flags for the CUDA compiler.\nmatmul_cuda_extension = load_inline(\n    name=\"matmul_cuda_extension\",\n    cpp_sources=cpp_source,\n    cuda_sources=cuda_source,\n    functions=[\"matmul_custom\"],\n    with_cuda=True,\n    extra_cuda_cflags=[\"-O3\", \"-arch=sm_75\", f\"-DBLOCK_SIZE={BLOCK_SIZE}\"]\n)\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    by replacing torch.matmul with a custom tiled CUDA kernel.\n    \"\"\"\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure inputs are on the CUDA device and have the correct float32 data type.\n        # This is crucial as the kernel operates directly on GPU memory and float32.\n        A = A.to(device='cuda', dtype=torch.float32)\n        B = B.to(device='cuda', dtype=torch.float32)\n\n        # Call the custom compiled CUDA function for matrix multiplication.\n        return matmul_cuda_extension.matmul_custom(", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\ncuda_source = \"\"\"\n#define TILE_SIZE 32\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n    // Calculate global row and column for the element C[row][col] that this thread will compute\n    int row = blockIdx.y * TILE_SIZE + threadIdx.y;\n    int col = blockIdx.x * TILE_SIZE + threadIdx.x;\n\n    // Accumulator for the C[row][col] element\n    float C_value = 0.0f;\n\n    // Declare shared memory for tiles of A and B\n    // Each thread block will load a TILE_SIZE x TILE_SIZE submatrix into shared memory\n    __shared__ float sA[TILE_SIZE][TILE_SIZE];\n    __shared__ float sB[TILE_SIZE][TILE_SIZE];\n\n    // Loop over the K dimension (inner product dimension) in steps of TILE_SIZE\n    for (int tile_k = 0; tile_k < N; tile_k += TILE_SIZE) {\n        // Load a tile of matrix A into shared memory (sA)\n        // Each thread loads one element. sA[threadIdx.y][threadIdx.x] will store A[row][tile_k + threadIdx.x]\n        int A_global_row = row;\n        int A_global_col = tile_k + threadIdx.x;\n        if (A_global_row < N && A_global_col < N) {\n            sA[threadIdx.y][threadIdx.x] = A[A_global_row * N + A_global_col];\n        } else {\n            sA[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Load a tile of matrix B into shared memory (sB)\n        // Each thread loads one element. sB[threadIdx.y][threadIdx.x] will store B[tile_k + threadIdx.y][col]\n        int B_global_row = tile_k + threadIdx.y;\n        int B_global_col = col;\n        if (B_global_row < N && B_global_col < N) {\n            sB[threadIdx.y][threadIdx.x] = B[B_global_row * N + B_global_col];\n        } else {\n            sB[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Synchronize threads to ensure all data is loaded into shared memory before computation begins\n        __syncthreads();\n\n        // Perform the dot product for the current tiles in shared memory\n        // Each thread computes its part of C_value using the loaded shared tiles\n        for (int k_inner = 0; k_inner < TILE_SIZE; ++k_inner) {\n            C_value += sA[threadIdx.y][k_inner] * sB[k_inner][threadIdx.x];\n        }\n\n        // Synchronize threads again to ensure all partial sums are computed before shared memory is reloaded\n        __syncthreads();\n    }\n\n    // Write the final computed value to global memory if within bounds\n    if (row < N && col < N) {\n        C[row * N + col] = C_value;\n    }\n}\n\"\"\"\n\ncpp_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda.h>\n#include <cuda_runtime.h>\n\n// Forward declaration of the CUDA kernel\nvoid matmul_kernel(const float* A, const float* B, float* C, int N);\n\ntorch::Tensor custom_matmul_forward(torch::Tensor A, torch::Tensor B) {\n    // Input validation\n    TORCH_CHECK(A.is_cuda() && B.is_cuda(), \"Inputs must be CUDA tensors.\");\n    TORCH_CHECK(A.is_contiguous() && B.is_contiguous(), \"Inputs must be contiguous.\");\n    TORCH_CHECK(A.dtype() == torch::kFloat32 && B.dtype() == torch::kFloat32, \"Inputs must be float32.\");\n    TORCH_CHECK(A.dim() == 2 && B.dim() == 2, \"Inputs must be 2D tensors.\");\n    \n    int N = A.size(0);\n    TORCH_CHECK(A.size(1) == N && B.size(0) == N && B.size(1) == N, \"Inputs must be square matrices of size N x N.\");\n\n    // Create the output tensor C on the same device and with the same dtype\n    torch::Tensor C = torch::empty({N, N}, A.options());\n\n    // Get raw pointers to the tensor data\n    const float* A_data = A.data_ptr<float>();\n    const float* B_data = B.data_ptr<float>();\n    float* C_data = C.data_ptr<float>();\n\n    // Define thread block and grid dimensions\n    const int TILE_SIZE = 32;\n    dim3 block_dim(TILE_SIZE, TILE_SIZE);\n    dim3 grid_dim((N + TILE_SIZE - 1) / TILE_SIZE, (N + TILE_SIZE - 1) / TILE_SIZE);\n\n    // Launch the CUDA kernel\n    matmul_kernel<<<grid_dim, block_dim>>>(A_data, B_data, C_data, N);\n\n    // Synchronize the CUDA stream to ensure kernel completion before returning\n    cudaStreamSynchronize(0); \n\n    return C;\n}\n\nPYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {\n    m.def(\"custom_matmul_forward\", &custom_matmul_forward, \"Custom Matrix Multiplication (CUDA)\");\n}\n\"\"\"\n\n# Compile and load the custom CUDA kernel\ncustom_matmul_extension = load_inline(\n    name=\"custom_matmul_extension\",\n    cpp_sources=cpp_source,\n    cuda_sources=cuda_source,\n    is_python_module=True,\n    extra_cuda_cflags=[\n        \"-O3\",\n        \"--use_fast_math\",\n    ],  # Optimization flags for the CUDA compiler\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom CUDA kernel with tiled matrix multiplication.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure input tensors are on the CUDA device before passing to the kernel\n        A_cuda = A.cuda()\n        B_cuda = B.cuda()\n\n        return custom_matmul_extension.custom_matmul_forward(A_cuda, B_cuda)", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# Define the CUDA kernel as a string\ncuda_source = \"\"\"\n#define TILE_SIZE 32 // Size of the tile in shared memory. Must be a power of 2.\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n    // Determine the global row and column for the C element computed by this thread.\n    // Each thread block computes a TILE_SIZE x TILE_SIZE tile of the output matrix C.\n    // threadIdx.y and threadIdx.x are the thread's coordinates within its block.\n    // blockIdx.y and blockIdx.x are the block's coordinates within the grid.\n    int globalRow = blockIdx.y * TILE_SIZE + threadIdx.y;\n    int globalCol = blockIdx.x * TILE_SIZE + threadIdx.x;\n\n    // Shared memory for tiles of A and B.\n    // These arrays store sub-matrices (tiles) that are frequently accessed by threads\n    // within the same block, reducing global memory traffic.\n    __shared__ float As[TILE_SIZE][TILE_SIZE];\n    __shared__ float Bs[TILE_SIZE][TILE_SIZE];\n\n    float Cvalue = 0; // Accumulator for the C[globalRow][globalCol] element.\n\n    // Loop over the K dimension (the reduction dimension in A*B) in steps of TILE_SIZE.\n    // In each iteration, a new pair of tiles from A and B are loaded into shared memory\n    // and used to update the Cvalue.\n    for (int k_idx = 0; k_idx < (N + TILE_SIZE - 1) / TILE_SIZE; ++k_idx) {\n        // Load a tile from matrix A into shared memory (As).\n        // Each thread loads one element.\n        int A_global_row = blockIdx.y * TILE_SIZE + threadIdx.y; // Row in A corresponding to C's row\n        int A_global_col = k_idx * TILE_SIZE + threadIdx.x;      // Column in A corresponding to K dimension\n        if (A_global_row < N && A_global_col < N) {\n            As[threadIdx.y][threadIdx.x] = A[A_global_row * N + A_global_col];\n        } else {\n            As[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zeros if out of bounds (for non-divisible N)\n        }\n\n        // Load a tile from matrix B into shared memory (Bs).\n        // Each thread loads one element.\n        int B_global_row = k_idx * TILE_SIZE + threadIdx.y;      // Row in B corresponding to K dimension\n        int B_global_col = blockIdx.x * TILE_SIZE + threadIdx.x; // Column in B corresponding to C's column\n        if (B_global_row < N && B_global_col < N) {\n            Bs[threadIdx.y][threadIdx.x] = B[B_global_row * N + B_global_col];\n        } else {\n            Bs[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Synchronize all threads in the block to ensure both As and Bs tiles are fully loaded\n        // before any thread starts computation with them.\n        __syncthreads();\n\n        // Perform the dot product computation for the current tiles.\n        // Each thread computes one element of the C tile by iterating through the TILE_SIZE dimension.\n        for (int i = 0; i < TILE_SIZE; ++i) {\n            Cvalue += As[threadIdx.y][i] * Bs[i][threadIdx.x];\n        }\n\n        // Synchronize all threads again to ensure all computations for the current tiles are complete\n        // before proceeding to load the next tiles in the next iteration.\n        __syncthreads();\n    }\n\n    // Store the final accumulated result from the shared memory tiles to the global output matrix C.\n    // Check boundaries in case N is not perfectly divisible by TILE_SIZE.\n    if (globalRow < N && globalCol < N) {\n        C[globalRow * N + globalCol] = Cvalue;\n    }\n}\n\"\"\"\n\n# Define the Python wrapper for the CUDA kernel\ncuda_function_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda.h>\n#include <cuda_runtime.h>\n\n// Declare the CUDA kernel function (defined in cuda_source)\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N);\n\ntorch::Tensor matmul_wrapper(const torch::Tensor& A, const torch::Tensor& B) {\n    // Ensure inputs are contiguous, on CUDA, and float32 for direct pointer access\n    TORCH_CHECK(A.is_cuda() && A.is_contiguous() && A.dtype() == torch::kFloat32, \"A must be a contiguous CUDA float32 tensor\");\n    TORCH_CHECK(B.is_cuda() && B.is_contiguous() && B.dtype() == torch::kFloat32, \"B must be a contiguous CUDA float32 tensor\");\n    \n    int N = A.size(0);\n    // Create an output tensor C on the same device and with the same dtype as A\n    torch::Tensor C = torch::zeros({N, N}, A.options());\n\n    // Define grid and block dimensions for the kernel launch.\n    // TILE_SIZE must match the #define in the kernel source.\n    const int TILE_SIZE = 32; \n    \n    // Grid dimensions: (N / TILE_SIZE) x (N / TILE_SIZE) blocks\n    // Using (N + TILE_SIZE - 1) / TILE_SIZE to correctly handle N not divisible by TILE_SIZE\n    dim3 dimGrid((N + TILE_SIZE - 1) / TILE_SIZE, (N + TILE_SIZE - 1) / TILE_SIZE);\n    \n    // Block dimensions: TILE_SIZE x TILE_SIZE threads per block\n    dim3 dimBlock(TILE_SIZE, TILE_SIZE);\n\n    // Launch the CUDA kernel\n    matmul_kernel<<<dimGrid, dimBlock>>>(\n        A.data_ptr<float>(), // Pointer to A's data\n        B.data_ptr<float>(), // Pointer to B's data\n        C.data_ptr<float>(), // Pointer to C's data\n        N                    // Matrix dimension\n    );\n\n    // No explicit cudaStreamSynchronize() or torch::cuda::synchronize() is typically needed\n    // here as PyTorch's ATen handles stream synchronization implicitly for subsequent operations\n    // or when the tensor is accessed from the CPU.\n\n    return C;\n}\n\"\"\"\n\n# Compile and load the CUDA kernel and its Python wrapper\n# This step happens once when the module is loaded.\nmodule = load_inline(\n    name=\"my_custom_matmul_extension\",  # Name of the compiled module\n    cpp_sources=cuda_function_source,\n    cuda_sources=cuda_source,\n    functions=[\"matmul_wrapper\"],  # List of C++ functions to expose to Python\n    verbose=True,  # Print compilation output\n    with_cuda=True,\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom CUDA kernel for performance improvement.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using a custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure inputs are on the CUDA device and have the required float32 precision.\n        # This conversion might involve a device transfer if inputs are on CPU.\n        A_cuda = A.to(torch.device(\"cuda\"), dtype=torch.float32)\n        B_cuda = B.to(torch.device(\"cuda\"), dtype=torch.float32)\n\n        # Call the custom CUDA kernel wrapper function\n        return module.matmul_wrapper(A_cuda, B_cuda)", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# Define the CUDA kernel as a string\ncuda_source = \"\"\"\n// TILE_SIZE is now defined via extra_cuda_cflags during compilation\n// Original line: #define TILE_SIZE 32 - Removed to avoid potential macro definition conflicts/issues with load_inline\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n    // Determine the global row and column for the C element computed by this thread.\n    int globalRow = blockIdx.y * TILE_SIZE + threadIdx.y;\n    int globalCol = blockIdx.x * TILE_SIZE + threadIdx.x;\n\n    // Shared memory for tiles of A and B. TILE_SIZE is guaranteed to be defined by extra_cuda_cflags.\n    __shared__ float As[TILE_SIZE][TILE_SIZE];\n    __shared__ float Bs[TILE_SIZE][TILE_SIZE];\n\n    float Cvalue = 0; // Accumulator for the C[globalRow][globalCol] element.\n\n    // Loop over the K dimension (the reduction dimension in A*B) in steps of TILE_SIZE.\n    for (int k_idx = 0; k_idx < (N + TILE_SIZE - 1) / TILE_SIZE; ++k_idx) {\n        // Load a tile from matrix A into shared memory (As).\n        int A_global_row = blockIdx.y * TILE_SIZE + threadIdx.y;\n        int A_global_col = k_idx * TILE_SIZE + threadIdx.x;\n        if (A_global_row < N && A_global_col < N) {\n            As[threadIdx.y][threadIdx.x] = A[A_global_row * N + A_global_col];\n        } else {\n            As[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Load a tile from matrix B into shared memory (Bs).\n        int B_global_row = k_idx * TILE_SIZE + threadIdx.y;\n        int B_global_col = blockIdx.x * TILE_SIZE + threadIdx.x;\n        if (B_global_row < N && B_global_col < N) {\n            Bs[threadIdx.y][threadIdx.x] = B[B_global_row * N + B_global_col];\n        } else {\n            Bs[threadIdx.y][threadIdx.x] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Synchronize all threads in the block to ensure both As and Bs tiles are fully loaded.\n        __syncthreads();\n\n        // Perform the dot product computation for the current tiles.\n        for (int i = 0; i < TILE_SIZE; ++i) {\n            Cvalue += As[threadIdx.y][i] * Bs[i][threadIdx.x];\n        }\n\n        // Synchronize all threads again to ensure all computations for the current tiles are complete.\n        __syncthreads();\n    }\n\n    // Store the final accumulated result from the shared memory tiles to the global output matrix C.\n    if (globalRow < N && globalCol < N) {\n        C[globalRow * N + globalCol] = Cvalue;\n    }\n}\n\"\"\"\n\n# Define the Python wrapper for the CUDA kernel\ncuda_function_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda.h>\n#include <cuda_runtime.h>\n\n// Declare the CUDA kernel function (defined in cuda_source)\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N);\n\ntorch::Tensor matmul_wrapper(const torch::Tensor& A, const torch::Tensor& B) {\n    // Ensure inputs are contiguous, on CUDA, and float32 for direct pointer access\n    TORCH_CHECK(A.is_cuda() && A.is_contiguous() && A.dtype() == torch::kFloat32, \"A must be a contiguous CUDA float32 tensor\");\n    TORCH_CHECK(B.is_cuda() && B.is_contiguous() && B.dtype() == torch::kFloat32, \"B must be a contiguous CUDA float32 tensor\");\n    \n    int N = A.size(0);\n    // Create an output tensor C on the same device and with the same dtype as A\n    torch::Tensor C = torch::zeros({N, N}, A.options());\n\n    // Define grid and block dimensions for the kernel launch.\n    // TILE_SIZE must match the definition used in the kernel.\n    const int TILE_SIZE = 32; \n    \n    // Grid dimensions: (N / TILE_SIZE) x (N / TILE_SIZE) blocks\n    // Using (N + TILE_SIZE - 1) / TILE_SIZE to correctly handle N not divisible by TILE_SIZE\n    dim3 dimGrid((N + TILE_SIZE - 1) / TILE_SIZE, (N + TILE_SIZE - 1) / TILE_SIZE);\n    \n    // Block dimensions: TILE_SIZE x TILE_SIZE threads per block\n    dim3 dimBlock(TILE_SIZE, TILE_SIZE);\n\n    // Launch the CUDA kernel\n    matmul_kernel<<<dimGrid, dimBlock>>>(\n        A.data_ptr<float>(), // Pointer to A's data\n        B.data_ptr<float>(), // Pointer to B's data\n        C.data_ptr<float>(), // Pointer to C's data\n        N                    // Matrix dimension\n    );\n\n    return C;\n}\n\"\"\"\n\n# Compile and load the CUDA kernel and its Python wrapper\n# TILE_SIZE is passed via extra_cuda_cflags to ensure it's defined for the CUDA kernel compilation.\nmodule = load_inline(\n    name=\"my_custom_matmul_extension\",\n    cpp_sources=cuda_function_source,\n    cuda_sources=cuda_source,\n    functions=[\"matmul_wrapper\"],\n    verbose=True,\n    with_cuda=True,\n    extra_cuda_cflags=[\"-DTILE_SIZE=32\"],  # Fix: Pass TILE_SIZE as a compiler flag\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom CUDA kernel for performance improvement.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using a custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure inputs are on the CUDA device and have the required float32 precision.\n        A_cuda = A.to(torch.device(\"cuda\"), dtype=torch.float32)\n        B_cuda = B.to(torch.device(\"cuda\"), dtype=torch.float32)\n\n        # Call the custom CUDA kernel wrapper function\n        return module.matmul_wrapper(A_cuda, B_cuda)"], "term_out": ["Unexpected evaluation error: 'NoneType' object is not callable", "Unexpected evaluation error: 'NoneType' object is not callable", "Evaluation returned None - likely concurrent compilation issue. Please retry.", "================================================================================COMPILATION FAILED================================================================================Error: builtins.RuntimeError\nError building extension 'my_custom_matmul_extension'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues.", "================================================================================COMPILATION FAILED================================================================================Error: builtins.RuntimeError\nError building extension 'my_custom_matmul_extension_v1'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues."], "analysis": ["Evaluation failed with error: EvaluationError", "Evaluation failed with error: EvaluationError", "Evaluation failed with error: LockFileError", "Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.RuntimeError. Review the error messages and fix the compilation issues.", "Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.RuntimeError. Review the error messages and fix the compilation issues."], "exp_name": "27-capable-mini-husky", "metrics": [0, 0, 0, 0, 0]}

let lastClick = 0;
let firstFrameTime = undefined;

let nodes = [];
let edges = [];

let lastScrollPos = 0;

setup = () => {
  canvas = createCanvas(...updateTargetDims());
};

class Node {
  x;
  y;
  size;
  xT;
  yT;
  xB;
  yB;
  treeInd;
  color;
  relSize;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  hasChildren = false;
  isRootNode = true;
  isStarred = false;
  selected = false;
  renderSize = 10;
  edges = [];
  bgCol;

  constructor(x, y, relSize, treeInd) {
    const minSize = 35;
    const maxSize = 60;

    const maxColor = 10;
    const minColor = 125;

    this.relSize = relSize;
    this.treeInd = treeInd;
    this.size = minSize + (maxSize - minSize) * relSize;
    this.color = minColor + (maxColor - minColor) * relSize;
    this.bgCol = Math.round(Math.max(this.color / 2, 0));

    this.x = x;
    this.y = y;
    this.xT = x;
    this.yT = y - this.size / 2;
    this.xB = x;
    this.yB = y + this.size / 2;

    nodes.push(this);
  }

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  child = (node) => {
    let edge = new Edge(this, node);
    this.edges.push(edge);
    edges.push(edge);
    this.hasChildren = true;
    node.isRootNode = false;
    return node;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    const mouseXlocalCoords = (mouseX - width / 2) / scaleFactor;
    const mouseYlocalCoords = (mouseY - height / 2) / scaleFactor;
    const isMouseOver =
      dist(mouseXlocalCoords, mouseYlocalCoords, this.x, this.y) <
      this.renderSize / 1.5;
    if (isMouseOver) cursor(HAND);
    if (isMouseOver && mouseIsPressed) {
      nodes.forEach((n) => (n.selected = false));
      this.selected = true;
      setCodeAndPlan(
        treeStructData.code[this.treeInd],
        treeStructData.plan[this.treeInd],
      );
      manualSelection = true;
    }

    this.renderSize = this.size;
    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
      } else {
        this.renderSize =
          this.size *
          (0.8 +
            0.2 *
              (-3.33 * this.animationProgress ** 2 +
                4.33 * this.animationProgress));
      }
    }

    fill(this.color);
    if (this.selected) {
      fill(accentCol);
    }

    noStroke();
    square(
      this.x - this.renderSize / 2,
      this.y - this.renderSize / 2,
      this.renderSize,
      10,
    );

    noStroke();
    textAlign(CENTER, CENTER);
    textSize(this.renderSize / 2);
    fill(255);
    // fill(lerpColor(color(accentCol), color(255), this.animationProgress))
    text("{ }", this.x, this.y - 1);
    // DEBUG PRINT:
    // text(round(this.relSize, 2), this.x, this.y - 1)
    // text(this.treeInd, this.x, this.y + 15)

    const dotAnimThreshold = 0.85;
    if (this.isStarred && this.animationProgress >= dotAnimThreshold) {
      let dotAnimProgress =
        (this.animationProgress - dotAnimThreshold) / (1 - dotAnimThreshold);
      textSize(
        ((-3.33 * dotAnimProgress ** 2 + 4.33 * dotAnimProgress) *
          this.renderSize) /
          2,
      );
      if (this.selected) {
        fill(0);
        stroke(0);
      } else {
        fill(accentCol);
        stroke(accentCol);
      }
      strokeWeight((-(dotAnimProgress ** 2) + dotAnimProgress) * 2);
      text("*", this.x + 20, this.y - 11);
      noStroke();
    }

    if (!this.isStatic) {
      fill(bgCol);
      const progressAnimBaseSize = this.renderSize + 5;
      rect(
        this.x - progressAnimBaseSize / 2,
        this.y -
          progressAnimBaseSize / 2 +
          progressAnimBaseSize * this.animationProgress,
        progressAnimBaseSize,
        progressAnimBaseSize * (1 - this.animationProgress),
      );
    }
    if (this.animationProgress >= 0.9) {
      this.edges
        .sort((a, b) => a.color() - b.color())
        .forEach((e, i) => {
          e.startAnimation((i / this.edges.length) ** 2 * 1000);
        });
    }
  };
}

class Edge {
  nodeT;
  nodeB;
  animX = 0;
  animY = 0;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  weight = 0;

  constructor(nodeT, nodeB) {
    this.nodeT = nodeT;
    this.nodeB = nodeB;
    this.weight = 2 + nodeB.relSize * 1;
  }

  color = () => this.nodeB.color;

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
        this.animX = this.nodeB.xT;
        this.animY = this.nodeB.yT;
      } else {
        this.animX = bezierPoint(
          this.nodeT.xB,
          this.nodeT.xB,
          this.nodeB.xT,
          this.nodeB.xT,
          this.animationProgress,
        );

        this.animY = bezierPoint(
          this.nodeT.yB,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          this.nodeB.yT,
          this.animationProgress,
        );
      }
    }
    if (this.animationProgress >= 0.97) {
      this.nodeB.startAnimation();
    }

    strokeWeight(this.weight);
    noFill();
    stroke(
      lerpColor(color(bgCol), color(accentCol), this.nodeB.relSize * 1 + 0.7),
    );
    bezier(
      this.nodeT.xB,
      this.nodeT.yB,
      this.nodeT.xB,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      this.animY,
    );
  };
}

draw = () => {
  cursor(ARROW);
  frameRate(120);
  if (!firstFrameTime && frameCount <= 1) {
    firstFrameTime = millis();
  }
  // ---- update global animation state ----
  const initialSpeedScalingEaseIO =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) * PI) + 1) / 2;
  const initialSpeedScalingEase =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) ** (1 / 2) * PI) + 1) / 2;
  const initAnimationSpeedFactor = 1.0 - 0.4 * initialSpeedScalingEaseIO;
  // update global scaling-aware clock
  globalTime += globalAnimSpeed * initAnimationSpeedFactor * deltaTime;

  if (nodes.length == 0) {
    const spacingHeight = height * 1.3;
    const spacingWidth = width * 1.3;
    treeStructData.layout.forEach((lay, index) => {
      new Node(
        spacingWidth * lay[0] - spacingWidth / 2,
        20 + spacingHeight * lay[1] - spacingHeight / 2,
        1 - treeStructData.metrics[index],
        index,
      );
    });
    treeStructData.edges.forEach((ind) => {
      nodes[ind[0]].child(nodes[ind[1]]);
    });
    nodes.forEach((n) => {
      if (n.isRootNode) n.startAnimation();
    });
    nodes[0].selected = true;
    setCodeAndPlan(
      treeStructData.code[0],
      treeStructData.plan[0],
    )
  }

  const staticNodes = nodes.filter(
    (n) => n.isStatic || n.animationProgress >= 0.7,
  );
  if (staticNodes.length > 0) {
    const largestNode = staticNodes.reduce((prev, current) =>
      prev.relSize > current.relSize ? prev : current,
    );
    if (!manualSelection) {
      if (!largestNode.selected) {
        setCodeAndPlan(
          treeStructData.code[largestNode.treeInd],
          treeStructData.plan[largestNode.treeInd],
        );
      }
      staticNodes.forEach((node) => {
        node.selected = node === largestNode;
      });
    }
  }
  background(bgCol);
  // global animation transforms
  translate(width / 2, height / 2);
  scale(scaleFactor);

  
  // ---- fg render ----
  edges.forEach((e) => e.render());
  nodes.forEach((n) => n.render());
  
};

    </script>
    <title>AIDE Run Visualization</title>
    <style>
      body,
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        overflow: scroll;
      }
      body {
        background-color: #f2f0e7;
      }
      canvas {
        float: left;
        height: 100vh;
        width: 40vw;
      }
      #text-container {
        float: right;
        height: 100vh;
        width: 50vw;
        background-color: #282c34;
      }
      #plan {
        /* border-left: 2px solid #282c34; */
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
      }
    </style>
  </head>
  <body>
    <pre
      id="text-container"
    ><div id="plan"></div><hr><code id="code" class="language-python"></code></pre>
  </body>
</html>
