<!doctype html>
<html lang="en"> 
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      id="p5scripttag"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
      integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <script>
      const bgCol = "#F2F0E7";
const accentCol = "#fd4578";

hljs.initHighlightingOnLoad();

const updateTargetDims = () => {
  // width is max-width of `.contentContainer` - its padding
  // return [min(windowWidth, 900 - 80), 700]
  return [windowWidth * (1 / 2), windowHeight];
};

const setCodeAndPlan = (code, plan) => {
  const codeElm = document.getElementById("code");
  if (codeElm) {
    // codeElm.innerText = code;
    codeElm.innerHTML = hljs.highlight(code, { language: "python" }).value;
  }

  const planElm = document.getElementById("plan");
  if (planElm) {
    // planElm.innerText = plan.trim();
    planElm.innerHTML = hljs.highlight(plan, { language: "plaintext" }).value;
  }
};

windowResized = () => {
  resizeCanvas(...updateTargetDims());
  awaitingPostResizeOps = true;
};

const animEase = (t) => 1 - (1 - Math.min(t, 1.0)) ** 5;

// ---- global constants ----

const globalAnimSpeed = 1.1;
const scaleFactor = 0.57;

// ---- global vars ----

let globalTime = 0;
let manualSelection = false;

let currentElemInd = 0;

let treeStructData = {"edges": [], "layout": [[0.0, 0.0], [0.25, 0.0], [0.5, 0.0], [0.75, 0.0], [1.0, 0.0]], "plan": ["### Optimization Plan  My approach focuses on implementing a custom CUDA kernel\nfor square matrix multiplication (GEMM) to replace `torch.matmul`. For this\ninitial implementation, I will prioritize correctness and basic parallelism.\nEach thread in the CUDA grid will be responsible for computing a single element\nof the output matrix `C`. The kernel will iterate through the inner dimension to\nsum the products of elements from the corresponding row of `A` and column of\n`B`. The C++ wrapper will handle tensor preparation (ensuring contiguous,\ncorrect device, and `fp32` precision) and configure the kernel launch with a 1D\ngrid.", "Optimization Plan: 1.  **Identify Bottleneck**: The core operation is\n`torch.matmul` for large square matrices, which is a prime candidate for GPU\noptimization. 2.  **Custom Kernel Implementation**: Replace the standard\n`torch.matmul` with a custom CUDA kernel. 3.  **Tiled GEMM Strategy**: Implement\na tiled General Matrix Multiplication (GEMM) kernel. This approach uses shared\nmemory to cache blocks of input matrices, improving data reuse and memory access\npatterns (coalescing), which are critical for high performance on GPUs. 4.\n**PyTorch Integration**: Use `torch.utils.cpp_extension.load_inline` to compile\nand integrate the custom CUDA kernel into the `ModelNew` class, ensuring it\nadheres to the original model's interface.", "The optimization plan involves replacing the standard `torch.matmul` operation\nwith a custom CUDA kernel. For large matrix multiplications, a tiled approach is\na fundamental optimization strategy. This involves breaking down the matrices\ninto smaller blocks (tiles), loading these tiles into faster on-chip shared\nmemory, performing sub-matrix multiplications, and accumulating the results.\nThis strategy maximizes data reuse and reduces global memory traffic, which are\ncritical for GPU performance.", "The optimization plan involves replacing the standard `torch.matmul` operator\nwith a custom CUDA kernel. For this initial implementation, I will focus on\ncorrectness by developing a straightforward untiled matrix multiplication\nkernel. Each CUDA thread will be responsible for computing a single element of\nthe output matrix `C`, iterating through the inner dimension `k`. A 2D grid and\nblock configuration will be used to map threads efficiently to the `(row, col)`\nindices of the output matrix. This custom kernel will then be integrated into\nthe `ModelNew` class using `torch.utils.cpp_extension.load_inline`.", "Optimization plan: The core operation is a square matrix multiplication (GEMM).\nI will implement a custom CUDA kernel using a tiled matrix multiplication\nstrategy. This involves dividing the matrices into smaller tiles that can be\nloaded into shared memory, performing sub-matrix products, and accumulating\nresults. This approach aims to reduce global memory traffic, improve data reuse\nthrough shared memory caching, and enhance memory access coalescing, leading to\nbetter performance than a naive global memory-bound implementation."], "code": ["import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# CUDA kernel source (includes both kernel and C++ wrapper)\ncuda_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda_runtime.h>\n\n// Naive matrix multiplication kernel\n// Each thread computes one element of the output matrix C.\n// C[row][col] = sum(A[row][k] * B[k][col]) for k from 0 to N-1\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n    // Calculate a unique global thread index\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n\n    // Ensure thread index is within bounds of the output matrix elements\n    if (idx < N * N) {\n        // Map 1D index to 2D row and column indices for the output matrix C\n        int row = idx / N;\n        int col = idx % N;\n\n        float sum = 0.0f;\n        // Perform the dot product for C[row][col]\n        for (int k = 0; k < N; ++k) {\n            // Access A[row][k] and B[k][col]\n            sum += A[row * N + k] * B[k * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\n// C++ wrapper function that prepares tensors and launches the CUDA kernel\ntorch::Tensor matmul_cuda(torch::Tensor A, torch::Tensor B) {\n    // Ensure inputs are contiguous, on CUDA device, and of float32 type\n    // .contiguous() is crucial for correct pointer arithmetic in the kernel\n    // .to(torch.float32) ensures fp32 precision\n    // .cuda() ensures tensors are on the GPU\n    A = A.contiguous().to(torch.float32).cuda();\n    B = B.contiguous().to(torch.float32).cuda();\n\n    // Get the matrix dimension N (assuming A and B are N x N square matrices)\n    int N = A.size(0); \n\n    // Allocate the output tensor C with the same shape, device, and dtype as A\n    auto C = torch::zeros({N, N}, A.options()); \n\n    // Define kernel launch configuration\n    // A common block size is 256 threads\n    const int block_size = 256; \n    // Total number of elements in the output matrix\n    const int num_elements = N * N;\n    // Calculate the number of blocks needed to cover all elements\n    const int num_blocks = (num_elements + block_size - 1) / block_size;\n\n    // Launch the CUDA kernel\n    // Pass raw data pointers and the matrix dimension N\n    matmul_kernel<<<num_blocks, block_size>>>(\n        A.data_ptr<float>(), // Pointer to the data of tensor A\n        B.data_ptr<float>(), // Pointer to the data of tensor B\n        C.data_ptr<float>(), // Pointer to the data of tensor C (output)\n        N                    // Matrix dimension N\n    );\n    \n    // Optional: Synchronize to catch any CUDA errors immediately during development\n    // cudaError_t err = cudaGetLastError();\n    // if (err != cudaSuccess) {\n    //     std::cerr << \"CUDA error in matmul_cuda: \" << cudaGetErrorString(err) << std::endl;\n    // }\n\n    return C;\n}\n\"\"\"\n\n# C++ function declaration. This must match the signature of the C++ wrapper function.\ncpp_source = \"torch::Tensor matmul_cuda(torch::Tensor A, torch::Tensor B);\"\n\n# Compile the inline CUDA code.\n# The 'name' argument defines the name of the compiled Python module.\n# 'functions' lists the C++ functions from the source to expose to Python.\ncustom_matmul_module = load_inline(\n    name=\"custom_matmul_extension\",\n    cpp_sources=cpp_source,  # C++ function declaration\n    cuda_sources=cuda_source,  # CUDA kernel implementation and C++ wrapper\n    functions=[\"matmul_cuda\"],  # List of functions to be callable from Python\n    verbose=True,  # Set to True to see compilation output\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that replaces torch.matmul with a custom CUDA kernel.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Store the compiled custom CUDA operation as an attribute\n        self.custom_matmul_op = custom_matmul_module\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Call the custom CUDA function through the loaded module\n        return self.custom_matmul_op.matmul_cuda(A, B)", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# CUDA kernel source (includes both kernel and C++ wrapper)\ncuda_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda_runtime.h>\n\n// Tiled matrix multiplication kernel\n__global__ void tiled_matmul_kernel(const float* A, const float* B, float* C, int N) {\n    const int TS = 32; // Tile size (e.g., 32x32 threads per block)\n\n    // Shared memory for tiles of A and B\n    __shared__ float As[TS][TS];\n    __shared__ float Bs[TS][TS];\n\n    // Thread coordinates within the block\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n\n    // Global row and column for the current thread's output C element\n    int row = blockIdx.y * TS + ty;\n    int col = blockIdx.x * TS + tx;\n\n    float Cvalue = 0.0f; // Accumulator for C[row][col]\n\n    // Loop over tiles of A and B along the K dimension\n    // Each iteration processes a TS x TS block of A and B, contributing to Cvalue\n    for (int k_tile_start = 0; k_tile_start < N; k_tile_start += TS) {\n        // Load tile of A into shared memory (As[ty][tx] corresponds to A[row][k_tile_start + tx])\n        // The current thread loads one element from A.\n        // row is fixed for the current thread. k_tile_start + tx covers the columns of the tile.\n        if (row < N && (k_tile_start + tx) < N) {\n            As[ty][tx] = A[row * N + (k_tile_start + tx)];\n        } else {\n            As[ty][tx] = 0.0f; // Pad with zero if out of bounds\n        }\n\n        // Load tile of B into shared memory (Bs[ty][tx] corresponds to B[k_tile_start + ty][col])\n        // The current thread loads one element from B.\n        // k_tile_start + ty covers the rows of the tile. col is fixed for the current thread.\n        if ((k_tile_start + ty) < N && col < N) {\n            Bs[ty][tx] = B[(k_tile_start + ty) * N + col];\n        } else {\n            Bs[ty][tx] = 0.0f; // Pad with zero if out of bounds\n        }\n        \n        // Synchronize all threads in the block to ensure shared memory tiles are fully loaded\n        __syncthreads();\n\n        // Perform dot product for the current tile contributions\n        // Each thread calculates one element of the TS x TS output C tile\n        for (int k = 0; k < TS; ++k) {\n            Cvalue += As[ty][k] * Bs[k][tx];\n        }\n\n        // Synchronize all threads in the block to ensure they've finished using the shared memory tiles\n        // before the next iteration loads new data\n        __syncthreads();\n    }\n\n    // Write the accumulated result to global memory\n    if (row < N && col < N) {\n        C[row * N + col] = Cvalue;\n    }\n}\n\n// C++ wrapper function to launch the CUDA kernel\ntorch::Tensor tiled_matmul_cuda(torch::Tensor A, torch::Tensor B) {\n    // Input validation\n    TORCH_CHECK(A.dim() == 2 && A.is_contiguous(), \"A must be a 2D contiguous tensor\");\n    TORCH_CHECK(B.dim() == 2 && B.is_contiguous(), \"B must be a 2D contiguous tensor\");\n    TORCH_CHECK(A.size(0) == A.size(1) && B.size(0) == B.size(1) && A.size(0) == B.size(0),\n                \"A and B must be square matrices of the same size (N x N)\");\n    TORCH_CHECK(A.dtype() == torch::kFloat && B.dtype() == torch::kFloat, \"Inputs must be float32\");\n\n    int N = A.size(0);\n    // Create output tensor C, ensuring it's on the same device as inputs\n    auto C = torch::zeros({N, N}, A.options()); \n\n    const int TS = 32; // Tile size (must match kernel's TS)\n    dim3 block_size(TS, TS); // Each block processes a TSxTS portion of C\n    dim3 grid_size((N + TS - 1) / TS, (N + TS - 1) / TS); // Grid of blocks\n\n    // Launch the kernel\n    tiled_matmul_kernel<<<grid_size, block_size>>>(\n        A.data_ptr<float>(), B.data_ptr<float>(), C.data_ptr<float>(), N);\n    \n    // Check for any CUDA errors that might have occurred during kernel execution\n    AT_CUDA_CHECK(cudaGetLastError());\n\n    return C;\n}\n\"\"\"\n\n# C++ function declaration for load_inline\ncpp_source = \"torch::Tensor tiled_matmul_cuda(torch::Tensor A, torch::Tensor B);\"\n\n# Compile the inline CUDA code\ncustom_matmul_extension = load_inline(\n    name=\"custom_matmul_extension\",\n    cpp_sources=cpp_source,\n    cuda_sources=cuda_source,\n    functions=[\"tiled_matmul_cuda\"],\n    verbose=True,\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs square matrix multiplication using a custom tiled CUDA kernel.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Store the compiled CUDA function\n        self.tiled_matmul_op = custom_matmul_extension.tiled_matmul_cuda\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        return self.tiled_matmul_op(A, B)", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# Optimization Plan:\n# The core operation is a large square matrix multiplication (N=4096).\n# I will implement a custom CUDA kernel for matrix multiplication using a tiled approach.\n# This approach will load sub-matrices (tiles) of A and B into shared memory,\n# allowing for faster access and reuse of data within each thread block.\n# This reduces global memory bandwidth pressure and exploits data locality,\n# which is a standard and effective basic optimization for GEMM on GPUs.\n\ncuda_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda_runtime.h>\n\n// Define BLOCK_SIZE for tiled matrix multiplication.\n// A common choice, typically a multiple of 32 for warp alignment.\n#define BLOCK_SIZE 32\n\n// CUDA kernel for tiled matrix multiplication\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n    // Dynamic shared memory allocation for tiles of A and B.\n    // Each tile is BLOCK_SIZE x BLOCK_SIZE.\n    extern __shared__ float sdata[];\n    float* As = (float*)sdata; // Tile for matrix A\n    float* Bs = (float*)(sdata + BLOCK_SIZE * BLOCK_SIZE); // Tile for matrix B\n\n    // Thread coordinates within the block\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n\n    // Global row and column for the C element this thread is responsible for\n    int row = blockIdx.y * BLOCK_SIZE + ty;\n    int col = blockIdx.x * BLOCK_SIZE + tx;\n\n    float Cvalue = 0.0f; // Accumulator for the C element\n\n    // Loop over tiles along the inner dimension (K dimension of A*B)\n    int num_tiles = (N + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    for (int k_tile = 0; k_tile < num_tiles; ++k_tile) {\n        // Load a tile of A into shared memory (As)\n        // Each thread loads one element. Accesses A in row-major fashion.\n        int A_global_row = row;\n        int A_global_col = k_tile * BLOCK_SIZE + tx;\n        if (A_global_row < N && A_global_col < N) {\n            As[ty * BLOCK_SIZE + tx] = A[A_global_row * N + A_global_col];\n        } else {\n            As[ty * BLOCK_SIZE + tx] = 0.0f; // Pad with zero for out-of-bounds access\n        }\n\n        // Load a tile of B into shared memory (Bs)\n        // Each thread loads one element. Accesses B in column-major fashion.\n        int B_global_row = k_tile * BLOCK_SIZE + ty;\n        int B_global_col = col;\n        if (B_global_row < N && B_global_col < N) {\n            Bs[ty * BLOCK_SIZE + tx] = B[B_global_row * N + B_global_col];\n        } else {\n            Bs[ty * BLOCK_SIZE + tx] = 0.0f; // Pad with zero for out-of-bounds access\n        }\n\n        // Synchronize threads in the block to ensure all shared memory loads are complete\n        __syncthreads();\n\n        // Perform matrix multiplication on the shared memory tiles\n        // Each thread computes one element of the partial product for its Cvalue\n        for (int p = 0; p < BLOCK_SIZE; ++p) {\n            Cvalue += As[ty * BLOCK_SIZE + p] * Bs[p * BLOCK_SIZE + tx];\n        }\n\n        // Synchronize threads to ensure all shared memory reads are complete\n        // before loading the next tile in the outer loop\n        __syncthreads();\n    }\n\n    // Write the accumulated Cvalue to global memory\n    if (row < N && col < N) {\n        C[row * N + col] = Cvalue;\n    }\n}\n\n// C++ wrapper function to launch the CUDA kernel\ntorch::Tensor matmul_cuda_wrapper(torch::Tensor A, torch::Tensor B) {\n    // Basic input validation\n    TORCH_CHECK(A.is_cuda() && B.is_cuda(), \"Inputs must be CUDA tensors.\");\n    TORCH_CHECK(A.is_contiguous() && B.is_contiguous(), \"Inputs must be contiguous.\");\n    TORCH_CHECK(A.dim() == 2 && B.dim() == 2, \"Inputs must be 2D matrices.\");\n    TORCH_CHECK(A.size(0) == A.size(1) && B.size(0) == B.size(1) && A.size(0) == B.size(0), \"Inputs must be square matrices of the same size.\");\n    TORCH_CHECK(A.dtype() == torch::kFloat && B.dtype() == torch::kFloat, \"Inputs must be float32.\");\n\n    int N = A.size(0);\n    auto C = torch::empty_like(A); // Allocate output tensor on the same device and with same dtype\n\n    // Define thread block dimensions (BLOCK_SIZE x BLOCK_SIZE)\n    dim3 block_dim(BLOCK_SIZE, BLOCK_SIZE);\n    \n    // Define grid dimensions to cover the entire N x N matrix\n    dim3 grid_dim(\n        (N + block_dim.x - 1) / block_dim.x,\n        (N + block_dim.y - 1) / block_dim.y\n    );\n\n    // Calculate dynamic shared memory size: two BLOCK_SIZE x BLOCK_SIZE float matrices\n    size_t shmem_size = 2 * BLOCK_SIZE * BLOCK_SIZE * sizeof(float);\n\n    // Launch the CUDA kernel\n    matmul_kernel<<<grid_dim, block_dim, shmem_size>>>(\n        A.data_ptr<float>(),\n        B.data_ptr<float>(),\n        C.data_ptr<float>(),\n        N\n    );\n    \n    // Check for any errors during kernel launch or execution\n    CUDA_CHECK(cudaGetLastError());\n\n    return C;\n}\n\"\"\"\n\ncpp_source = \"torch::Tensor matmul_cuda_wrapper(torch::Tensor A, torch::Tensor B);\"\n\n# Compile the inline CUDA code using torch.utils.cpp_extension\n_matmul_cuda = load_inline(\n    name=\"matmul_extension\",\n    cpp_sources=cpp_source,\n    cuda_sources=cuda_source,\n    functions=[\"matmul_cuda_wrapper\"],\n    verbose=True,  # Set to True to see compilation output\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom tiled CUDA kernel implemented via torch.utils.cpp_extension.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Store the compiled CUDA function\n        self.matmul_op = _matmul_cuda.matmul_cuda_wrapper\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure inputs are on the CUDA device and in float32 precision\n        # before passing them to the custom CUDA kernel.\n        A_cuda = A.to(\"cuda\", dtype=torch.float32)\n        B_cuda = B.to(\"cuda\", dtype=torch.float32)\n\n        # Call the custom CUDA matrix multiplication function\n        return self.matmul_op(A_cuda, B_cuda)", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# CUDA kernel source (includes both kernel and C++ wrapper)\ncuda_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda_runtime.h>\n\n// Untiled matrix multiplication kernel\n// Each thread computes one element C[row][col]\n__global__ void matrix_multiply_kernel(const float* A, const float* B, float* C, int N) {\n    // Calculate global row and column index\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    // Check bounds to prevent out-of-bounds access\n    if (row < N && col < N) {\n        float sum = 0.0f;\n        for (int k = 0; k < N; ++k) {\n            sum += A[row * N + k] * B[k * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\n// C++ wrapper function to launch the CUDA kernel\ntorch::Tensor matrix_multiply_cuda(torch::Tensor A, torch::Tensor B) {\n    // Input validation\n    TORCH_CHECK(A.dim() == 2 && B.dim() == 2, \"Inputs must be 2D matrices.\");\n    TORCH_CHECK(A.size(1) == B.size(0), \"Inner dimensions must match for matrix multiplication.\");\n    TORCH_CHECK(A.size(0) == B.size(1), \"For square matrix multiplication, dimensions must be N x N.\");\n    TORCH_CHECK(A.is_contiguous() && B.is_contiguous(), \"Inputs must be contiguous.\");\n    TORCH_CHECK(A.dtype() == torch::kFloat32 && B.dtype() == torch::kFloat32, \"Inputs must be float32.\");\n    TORCH_CHECK(A.device().is_cuda && B.device().is_cuda, \"Inputs must be on CUDA device.\");\n\n    int N = A.size(0); // Assuming square matrices N x N\n\n    // Allocate output tensor on the same device and with same dtype as inputs\n    auto C = torch::zeros({N, N}, A.options());\n\n    // Define thread block and grid dimensions\n    // Using 32x32 threads per block, which is a common and efficient size (1024 threads total)\n    const int BLOCK_DIM_X = 32;\n    const int BLOCK_DIM_Y = 32;\n    \n    dim3 block_size(BLOCK_DIM_X, BLOCK_DIM_Y);\n    dim3 grid_size((N + BLOCK_DIM_X - 1) / BLOCK_DIM_X, (N + BLOCK_DIM_Y - 1) / BLOCK_DIM_Y);\n\n    // Launch the CUDA kernel\n    matrix_multiply_kernel<<<grid_size, block_size>>>(\n        A.data_ptr<float>(), B.data_ptr<float>(), C.data_ptr<float>(), N);\n    \n    return C;\n}\n\"\"\"\n\n# C++ function declaration\ncpp_source = \"torch::Tensor matrix_multiply_cuda(torch::Tensor A, torch::Tensor B);\"\n\n# Compile the inline CUDA code once\n# The 'verbose=True' argument provides compilation details, useful for debugging.\nmatrix_multiply_module = load_inline(\n    name=\"custom_matrix_multiply\",\n    cpp_sources=cpp_source,\n    cuda_sources=cuda_source,\n    functions=[\"matrix_multiply_cuda\"],\n    verbose=True,\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom CUDA kernel.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Store the compiled custom CUDA function as an attribute\n        self.custom_matmul = matrix_multiply_module.matrix_multiply_cuda\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        return self.custom_matmul(A, B)", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\ncuda_source = \"\"\"\n#include <torch/extension.h>\n#include <cuda_runtime.h>\n\n// TILE_DIM defines the tile size for shared memory and thread block dimensions.\n#define TILE_DIM 32\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int N) {\n    // Block index in the grid\n    int blockRow = blockIdx.y;\n    int blockCol = blockIdx.x;\n\n    // Thread index within the block\n    int threadRow = threadIdx.y;\n    int threadCol = threadIdx.x;\n\n    // Calculate the global row and column for the C element this thread is responsible for\n    int C_row = blockRow * TILE_DIM + threadRow;\n    int C_col = blockCol * TILE_DIM + threadCol;\n\n    // Declare shared memory for tiles of A and B\n    __shared__ float sA[TILE_DIM][TILE_DIM];\n    __shared__ float sB[TILE_DIM][TILE_DIM];\n\n    float Cvalue = 0.0f; // Accumulator for the C element\n\n    // Iterate over the 'k' dimension (inner product dimension) in tiles\n    // Each iteration processes a pair of A and B tiles\n    for (int tile = 0; tile < (N + TILE_DIM - 1) / TILE_DIM; ++tile) {\n        // Load a tile of A from global memory to shared memory\n        // Each thread loads one element from A\n        int k_global_A = tile * TILE_DIM + threadCol;\n        if (C_row < N && k_global_A < N) {\n            sA[threadRow][threadCol] = A[C_row * N + k_global_A];\n        } else {\n            sA[threadRow][threadCol] = 0.0f; // Pad with zeros for out-of-bounds access\n        }\n\n        // Load a tile of B from global memory to shared memory\n        // Each thread loads one element from B\n        int k_global_B = tile * TILE_DIM + threadRow;\n        if (k_global_B < N && C_col < N) {\n            sB[threadRow][threadCol] = B[k_global_B * N + C_col];\n        } else {\n            sB[threadRow][threadCol] = 0.0f; // Pad with zeros for out-of-bounds access\n        }\n        \n        __syncthreads(); // Synchronize to ensure all shared memory loads are complete\n\n        // Perform the matrix multiplication for the current tiles\n        // Each thread computes its part of the dot product\n        for (int k = 0; k < TILE_DIM; ++k) {\n            Cvalue += sA[threadRow][k] * sB[k][threadCol];\n        }\n        \n        __syncthreads(); // Synchronize to ensure all threads finish using current sA/sB before next load\n    }\n\n    // Write the accumulated result from register to global memory\n    if (C_row < N && C_col < N) {\n        C[C_row * N + C_col] = Cvalue;\n    }\n}\n\n// C++ wrapper function to launch the CUDA kernel\ntorch::Tensor matmul_cuda_wrapper(torch::Tensor A, torch::Tensor B) {\n    // Basic input validation\n    TORCH_CHECK(A.is_cuda(), \"A must be a CUDA tensor\");\n    TORCH_CHECK(B.is_cuda(), \"B must be a CUDA tensor\");\n    TORCH_CHECK(A.dtype() == torch::kFloat, \"A must be float32\");\n    TORCH_CHECK(B.dtype() == torch::kFloat, \"B must be float32\");\n    TORCH_CHECK(A.dim() == 2 && B.dim() == 2, \"Inputs must be 2D matrices\");\n    TORCH_CHECK(A.size(0) == A.size(1) && B.size(0) == B.size(1), \"Inputs must be square matrices\");\n    TORCH_CHECK(A.size(1) == B.size(0), \"Matrix dimensions must match for multiplication\");\n\n    int N = A.size(0);\n\n    // Create the output tensor on the same device as inputs\n    auto C = torch::empty({N, N}, A.options());\n\n    // Define block and grid dimensions\n    // Each block processes a TILE_DIM x TILE_DIM sub-matrix of C\n    dim3 block_dim(TILE_DIM, TILE_DIM);\n    dim3 grid_dim((N + TILE_DIM - 1) / TILE_DIM, (N + TILE_DIM - 1) / TILE_DIM);\n\n    // Launch the CUDA kernel\n    matmul_kernel<<<grid_dim, block_dim>>>(\n        A.data_ptr<float>(),\n        B.data_ptr<float>(),\n        C.data_ptr<float>(),\n        N\n    );\n\n    return C;\n}\n\"\"\"\n\ncpp_source = \"torch::Tensor matmul_cuda_wrapper(torch::Tensor A, torch::Tensor B);\"\n\n# Compile the inline CUDA code using torch.utils.cpp_extension.load_inline\nmatmul_custom = load_inline(\n    name=\"matmul_custom_extension\",\n    cpp_sources=cpp_source,\n    cuda_sources=cuda_source,\n    functions=[\"matmul_cuda_wrapper\"],\n    verbose=True,  # Set to True to see compilation output\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom tiled CUDA kernel.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Store the compiled custom operation as a member\n        self.matmul_op = matmul_custom.matmul_cuda_wrapper\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        return self.matmul_op(A, B)"], "term_out": ["================================================================================COMPILATION FAILED================================================================================Error: builtins.RuntimeError\nError building extension 'custom_matmul_extension'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues.", "================================================================================COMPILATION FAILED================================================================================Error: builtins.RuntimeError\nError building extension 'custom_matmul_extension_v1'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues.", "================================================================================COMPILATION FAILED================================================================================Error: builtins.RuntimeError\nError building extension 'matmul_extension'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues.", "================================================================================COMPILATION FAILED================================================================================Error: builtins.RuntimeError\nError building extension 'custom_matrix_multiply'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues.", "================================================================================KERNEL EVALUATION SUCCESS================================================================================\u2713 Compilation: PASSED\u2713 Correctness: PASSED  Correctness trials: (5 / 5)\n\u2713 Performance: 37.600 ms  Mean: 37.600 ms  Std:  0.378 ms  Min:  37.500 ms  Max:  40.900 ms  Trials: 100\nHardware: NVIDIA TITAN VRuntime: 0.038 seconds"], "analysis": ["Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.RuntimeError. Review the error messages and fix the compilation issues.", "Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.RuntimeError. Review the error messages and fix the compilation issues.", "Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.RuntimeError. Review the error messages and fix the compilation issues.", "Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.RuntimeError. Review the error messages and fix the compilation issues.", "Kernel implementation successful! Runtime: 37.600 ms. The kernel compiled correctly, passed all correctness checks, and was successfully profiled."], "exp_name": "40-sincere-notorious-bittern", "metrics": [0, 0, 0, 0, 0]}

let lastClick = 0;
let firstFrameTime = undefined;

let nodes = [];
let edges = [];

let lastScrollPos = 0;

setup = () => {
  canvas = createCanvas(...updateTargetDims());
};

class Node {
  x;
  y;
  size;
  xT;
  yT;
  xB;
  yB;
  treeInd;
  color;
  relSize;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  hasChildren = false;
  isRootNode = true;
  isStarred = false;
  selected = false;
  renderSize = 10;
  edges = [];
  bgCol;

  constructor(x, y, relSize, treeInd) {
    const minSize = 35;
    const maxSize = 60;

    const maxColor = 10;
    const minColor = 125;

    this.relSize = relSize;
    this.treeInd = treeInd;
    this.size = minSize + (maxSize - minSize) * relSize;
    this.color = minColor + (maxColor - minColor) * relSize;
    this.bgCol = Math.round(Math.max(this.color / 2, 0));

    this.x = x;
    this.y = y;
    this.xT = x;
    this.yT = y - this.size / 2;
    this.xB = x;
    this.yB = y + this.size / 2;

    nodes.push(this);
  }

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  child = (node) => {
    let edge = new Edge(this, node);
    this.edges.push(edge);
    edges.push(edge);
    this.hasChildren = true;
    node.isRootNode = false;
    return node;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    const mouseXlocalCoords = (mouseX - width / 2) / scaleFactor;
    const mouseYlocalCoords = (mouseY - height / 2) / scaleFactor;
    const isMouseOver =
      dist(mouseXlocalCoords, mouseYlocalCoords, this.x, this.y) <
      this.renderSize / 1.5;
    if (isMouseOver) cursor(HAND);
    if (isMouseOver && mouseIsPressed) {
      nodes.forEach((n) => (n.selected = false));
      this.selected = true;
      setCodeAndPlan(
        treeStructData.code[this.treeInd],
        treeStructData.plan[this.treeInd],
      );
      manualSelection = true;
    }

    this.renderSize = this.size;
    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
      } else {
        this.renderSize =
          this.size *
          (0.8 +
            0.2 *
              (-3.33 * this.animationProgress ** 2 +
                4.33 * this.animationProgress));
      }
    }

    fill(this.color);
    if (this.selected) {
      fill(accentCol);
    }

    noStroke();
    square(
      this.x - this.renderSize / 2,
      this.y - this.renderSize / 2,
      this.renderSize,
      10,
    );

    noStroke();
    textAlign(CENTER, CENTER);
    textSize(this.renderSize / 2);
    fill(255);
    // fill(lerpColor(color(accentCol), color(255), this.animationProgress))
    text("{ }", this.x, this.y - 1);
    // DEBUG PRINT:
    // text(round(this.relSize, 2), this.x, this.y - 1)
    // text(this.treeInd, this.x, this.y + 15)

    const dotAnimThreshold = 0.85;
    if (this.isStarred && this.animationProgress >= dotAnimThreshold) {
      let dotAnimProgress =
        (this.animationProgress - dotAnimThreshold) / (1 - dotAnimThreshold);
      textSize(
        ((-3.33 * dotAnimProgress ** 2 + 4.33 * dotAnimProgress) *
          this.renderSize) /
          2,
      );
      if (this.selected) {
        fill(0);
        stroke(0);
      } else {
        fill(accentCol);
        stroke(accentCol);
      }
      strokeWeight((-(dotAnimProgress ** 2) + dotAnimProgress) * 2);
      text("*", this.x + 20, this.y - 11);
      noStroke();
    }

    if (!this.isStatic) {
      fill(bgCol);
      const progressAnimBaseSize = this.renderSize + 5;
      rect(
        this.x - progressAnimBaseSize / 2,
        this.y -
          progressAnimBaseSize / 2 +
          progressAnimBaseSize * this.animationProgress,
        progressAnimBaseSize,
        progressAnimBaseSize * (1 - this.animationProgress),
      );
    }
    if (this.animationProgress >= 0.9) {
      this.edges
        .sort((a, b) => a.color() - b.color())
        .forEach((e, i) => {
          e.startAnimation((i / this.edges.length) ** 2 * 1000);
        });
    }
  };
}

class Edge {
  nodeT;
  nodeB;
  animX = 0;
  animY = 0;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  weight = 0;

  constructor(nodeT, nodeB) {
    this.nodeT = nodeT;
    this.nodeB = nodeB;
    this.weight = 2 + nodeB.relSize * 1;
  }

  color = () => this.nodeB.color;

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
        this.animX = this.nodeB.xT;
        this.animY = this.nodeB.yT;
      } else {
        this.animX = bezierPoint(
          this.nodeT.xB,
          this.nodeT.xB,
          this.nodeB.xT,
          this.nodeB.xT,
          this.animationProgress,
        );

        this.animY = bezierPoint(
          this.nodeT.yB,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          this.nodeB.yT,
          this.animationProgress,
        );
      }
    }
    if (this.animationProgress >= 0.97) {
      this.nodeB.startAnimation();
    }

    strokeWeight(this.weight);
    noFill();
    stroke(
      lerpColor(color(bgCol), color(accentCol), this.nodeB.relSize * 1 + 0.7),
    );
    bezier(
      this.nodeT.xB,
      this.nodeT.yB,
      this.nodeT.xB,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      this.animY,
    );
  };
}

draw = () => {
  cursor(ARROW);
  frameRate(120);
  if (!firstFrameTime && frameCount <= 1) {
    firstFrameTime = millis();
  }
  // ---- update global animation state ----
  const initialSpeedScalingEaseIO =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) * PI) + 1) / 2;
  const initialSpeedScalingEase =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) ** (1 / 2) * PI) + 1) / 2;
  const initAnimationSpeedFactor = 1.0 - 0.4 * initialSpeedScalingEaseIO;
  // update global scaling-aware clock
  globalTime += globalAnimSpeed * initAnimationSpeedFactor * deltaTime;

  if (nodes.length == 0) {
    const spacingHeight = height * 1.3;
    const spacingWidth = width * 1.3;
    treeStructData.layout.forEach((lay, index) => {
      new Node(
        spacingWidth * lay[0] - spacingWidth / 2,
        20 + spacingHeight * lay[1] - spacingHeight / 2,
        1 - treeStructData.metrics[index],
        index,
      );
    });
    treeStructData.edges.forEach((ind) => {
      nodes[ind[0]].child(nodes[ind[1]]);
    });
    nodes.forEach((n) => {
      if (n.isRootNode) n.startAnimation();
    });
    nodes[0].selected = true;
    setCodeAndPlan(
      treeStructData.code[0],
      treeStructData.plan[0],
    )
  }

  const staticNodes = nodes.filter(
    (n) => n.isStatic || n.animationProgress >= 0.7,
  );
  if (staticNodes.length > 0) {
    const largestNode = staticNodes.reduce((prev, current) =>
      prev.relSize > current.relSize ? prev : current,
    );
    if (!manualSelection) {
      if (!largestNode.selected) {
        setCodeAndPlan(
          treeStructData.code[largestNode.treeInd],
          treeStructData.plan[largestNode.treeInd],
        );
      }
      staticNodes.forEach((node) => {
        node.selected = node === largestNode;
      });
    }
  }
  background(bgCol);
  // global animation transforms
  translate(width / 2, height / 2);
  scale(scaleFactor);

  
  // ---- fg render ----
  edges.forEach((e) => e.render());
  nodes.forEach((n) => n.render());
  
};

    </script>
    <title>AIDE Run Visualization</title>
    <style>
      body,
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        overflow: scroll;
      }
      body {
        background-color: #f2f0e7;
      }
      canvas {
        float: left;
        height: 100vh;
        width: 40vw;
      }
      #text-container {
        float: right;
        height: 100vh;
        width: 50vw;
        background-color: #282c34;
      }
      #plan {
        /* border-left: 2px solid #282c34; */
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
      }
    </style>
  </head>
  <body>
    <pre
      id="text-container"
    ><div id="plan"></div><hr><code id="code" class="language-python"></code></pre>
  </body>
</html>
