<!doctype html>
<html lang="en"> 
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      id="p5scripttag"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
      integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <script>
      const bgCol = "#F2F0E7";
const accentCol = "#fd4578";

hljs.initHighlightingOnLoad();

const updateTargetDims = () => {
  // width is max-width of `.contentContainer` - its padding
  // return [min(windowWidth, 900 - 80), 700]
  return [windowWidth * (1 / 2), windowHeight];
};

const setCodeAndPlan = (code, plan) => {
  const codeElm = document.getElementById("code");
  if (codeElm) {
    // codeElm.innerText = code;
    codeElm.innerHTML = hljs.highlight(code, { language: "python" }).value;
  }

  const planElm = document.getElementById("plan");
  if (planElm) {
    // planElm.innerText = plan.trim();
    planElm.innerHTML = hljs.highlight(plan, { language: "plaintext" }).value;
  }
};

windowResized = () => {
  resizeCanvas(...updateTargetDims());
  awaitingPostResizeOps = true;
};

const animEase = (t) => 1 - (1 - Math.min(t, 1.0)) ** 5;

// ---- global constants ----

const globalAnimSpeed = 1.1;
const scaleFactor = 0.57;

// ---- global vars ----

let globalTime = 0;
let manualSelection = false;

let currentElemInd = 0;

let treeStructData = {"edges": [], "layout": [[0.0, 0.0], [1.0, 0.0]], "plan": ["Optimization Plan: 1. Replace `torch.matmul` with a custom CUDA kernel for\nsquare matrix multiplication. 2. Implement a tiled matrix multiplication\nalgorithm within the CUDA kernel, leveraging shared memory to improve data reuse\nand reduce global memory traffic. 3. Each thread block will compute a `32x32`\ntile of the output matrix, with threads cooperatively loading data into shared\nmemory. 4. The kernel will be compiled via\n`torch.utils.cpp_extension.load_inline` with aggressive optimization flags for\nmaximum performance. 5. Inputs will be explicitly moved to the GPU and ensured\nto be `float32` before the kernel launch.", "The optimization plan is to implement a custom CUDA kernel for the square matrix\nmultiplication. This kernel will use a tiled approach with shared memory to\nimprove data locality and reduce global memory accesses. Each thread block will\nbe responsible for computing a tile of the output matrix, loading corresponding\ntiles from the input matrices into shared memory, performing the dot product,\nand writing the result back to global memory. This strategy prioritizes\ncorrectness and fundamental GPU optimization techniques."], "code": ["import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\ncuda_source = \"\"\"\n#define TILE_SIZE 32\n\n__global__ void matmul_tiled_fp32(const float* A, const float* B, float* C, int N) {\n    // Shared memory for tiles of A and B\n    // Each block loads two TILE_SIZE x TILE_SIZE tiles into shared memory.\n    // Total shared memory per block: 2 * TILE_SIZE * TILE_SIZE * sizeof(float)\n    // For TILE_SIZE=32, this is 2 * 32 * 32 * 4 bytes = 8192 bytes, well within typical limits.\n    __shared__ float sA[TILE_SIZE][TILE_SIZE];\n    __shared__ float sB[TILE_SIZE][TILE_SIZE];\n\n    // Thread coordinates within the block\n    int tx = threadIdx.x; // Column index within the block (0 to TILE_SIZE-1)\n    int ty = threadIdx.y; // Row index within the block (0 to TILE_SIZE-1)\n\n    // Global row and column for the current thread's C element\n    int row = blockIdx.y * TILE_SIZE + ty;\n    int col = blockIdx.x * TILE_SIZE + tx;\n\n    float C_value = 0.0f; // Accumulator for the C[row][col] element\n\n    // Loop over tiles along the K dimension (inner dimension of matrix multiplication)\n    // (N + TILE_SIZE - 1) / TILE_SIZE calculates ceil(N / TILE_SIZE)\n    for (int k_tile_idx = 0; k_tile_idx < (N + TILE_SIZE - 1) / TILE_SIZE; ++k_tile_idx) {\n        // Calculate the starting index for the current K-tile\n        int k_start = k_tile_idx * TILE_SIZE;\n\n        // Load a tile from matrix A into shared memory sA\n        // Each thread (ty, tx) loads one element sA[ty][tx]\n        // This element comes from A[row][k_start + tx]\n        if (row < N && (k_start + tx) < N) {\n            sA[ty][tx] = A[row * N + (k_start + tx)];\n        } else {\n            sA[ty][tx] = 0.0f; // Pad with zeros if outside matrix A bounds\n        }\n\n        // Load a tile from matrix B into shared memory sB\n        // Each thread (ty, tx) loads one element sB[ty][tx]\n        // This element comes from B[k_start + ty][col]\n        if ((k_start + ty) < N && col < N) {\n            sB[ty][tx] = B[(k_start + ty) * N + col];\n        } else {\n            sB[ty][tx] = 0.0f; // Pad with zeros if outside matrix B bounds\n        }\n\n        // Synchronize threads within the block.\n        // Ensures all threads have finished loading their part of sA and sB\n        // before any thread starts using them for computation.\n        __syncthreads();\n\n        // Perform the dot product for the C_value using the shared memory tiles\n        // C_value += sA[ty][i] * sB[i][tx]\n        for (int i = 0; i < TILE_SIZE; ++i) {\n            C_value += sA[ty][i] * sB[i][tx];\n        }\n\n        // Synchronize threads within the block again.\n        // Ensures all threads have finished their computation on the current shared tiles\n        // before the next iteration loads new data into sA and sB.\n        __syncthreads();\n    }\n\n    // Store the final accumulated result into global memory C\n    // Only write if the global row and column are within the matrix bounds.\n    if (row < N && col < N) {\n        C[row * N + col] = C_value;\n    }\n}\n\"\"\"\n\n# Compile and load the CUDA kernel\nmatmul_extension = load_inline(\n    name=\"matmul_extension\",\n    cuda_sources=[cuda_source],\n    functions=[\"matmul_tiled_fp32\"],\n    extra_cuda_cflags=[\"-O3\", \"--use_fast_math\"],  # Aggressive optimization flags\n)\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom tiled CUDA kernel with shared memory.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Store the loaded CUDA kernel function\n        self.matmul_op = matmul_extension.matmul_tiled_fp32\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Ensure inputs are on CUDA device and are float32\n        A = A.to(torch.device(\"cuda\"), dtype=torch.float32)\n        B = B.to(torch.device(\"cuda\"), dtype=torch.float32)\n\n        N = A.shape[0]  # Assuming A and B are square matrices of shape (N, N)\n\n        # Create an output tensor on the CUDA device with the same shape and dtype as A\n        C = torch.empty((N, N), device=A.device, dtype=A.dtype)\n\n        # Define TILE_SIZE (must match the one in the kernel source)\n        TILE_SIZE = 32\n\n        # Calculate grid and block dimensions for the kernel launch\n        # Grid dimensions: Number of blocks needed to cover the N x N output matrix\n        grid_dim_x = (N + TILE_SIZE - 1) // TILE_SIZE\n        grid_dim_y = (N + TILE_SIZE - 1) // TILE_SIZE\n\n        # Block dimensions: TILE_SIZE x TILE_SIZE threads per block\n        block_dim_x = TILE_SIZE\n        block_dim_y = TILE_SIZE\n\n        # Launch the custom CUDA kernel\n        # The 'grid' and 'block' arguments specify the dimensions for the kernel launch.\n        self.matmul_op(\n            A, B, C, N, grid=(grid_dim_x, grid_dim_y), block=(block_dim_x, block_dim_y)\n        )\n\n        return C", "import torch\nimport torch.nn as nn\nfrom torch.utils.cpp_extension import load_inline\n\n# Define the CUDA kernel as a string\n# TILE_SIZE defines the dimensions of the square tile computed by each thread block\n# A common TILE_SIZE is 32, which results in 32*32 = 1024 threads per block,\n# often a good fit for modern GPUs.\ncuda_source = \"\"\"\n#define TILE_SIZE 32\n\n__global__ void matmul_tiled_kernel(const float* A, const float* B, float* C, int N) {\n    // Block index\n    int blockRow = blockIdx.y;\n    int blockCol = blockIdx.x;\n\n    // Thread index within the block\n    int threadRow = threadIdx.y; // 0 to TILE_SIZE-1\n    int threadCol = threadIdx.x; // 0 to TILE_SIZE-1\n\n    // Global row and column for the current thread in the output matrix C\n    int globalRow = blockRow * TILE_SIZE + threadRow;\n    int globalCol = blockCol * TILE_SIZE + threadCol;\n\n    // Shared memory for tiles of A and B\n    // These arrays store TILE_SIZE x TILE_SIZE tiles\n    __shared__ float sA[TILE_SIZE][TILE_SIZE];\n    __shared__ float sB[TILE_SIZE][TILE_SIZE];\n\n    // Cvalue accumulates the dot product for the element computed by this thread\n    float Cvalue = 0.0f;\n\n    // Loop over the \"strips\" of A and B that are multiplied\n    // k_tile_start iterates through the inner dimension of the matrix multiplication,\n    // stepping by TILE_SIZE for each shared memory tile load.\n    for (int k_tile_start = 0; k_tile_start < N; k_tile_start += TILE_SIZE) {\n        // Load a tile from matrix A into shared memory sA\n        // Each thread loads one element. The element is from A[globalRow][k_tile_start + threadCol]\n        // Boundary checks are added for robustness, though for N being a multiple of TILE_SIZE,\n        // these conditions will always be true for active threads.\n        if (globalRow < N && (k_tile_start + threadCol) < N) {\n            sA[threadRow][threadCol] = A[globalRow * N + (k_tile_start + threadCol)];\n        } else {\n            sA[threadRow][threadCol] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Load a tile from matrix B into shared memory sB\n        // Each thread loads one element. The element is from B[k_tile_start + threadRow][globalCol]\n        if ((k_tile_start + threadRow) < N && globalCol < N) {\n            sB[threadRow][threadCol] = B[(k_tile_start + threadRow) * N + globalCol];\n        } else {\n            sB[threadRow][threadCol] = 0.0f; // Pad with zeros if out of bounds\n        }\n\n        // Synchronize all threads in the block to ensure both shared memory tiles are fully loaded\n        // before any thread starts computation.\n        __syncthreads();\n\n        // Perform the dot product for the current tile\n        // Each thread computes its contribution to Cvalue by iterating through the loaded tiles.\n        for (int i = 0; i < TILE_SIZE; ++i) {\n            Cvalue += sA[threadRow][i] * sB[i][threadCol];\n        }\n\n        // Synchronize all threads in the block again to ensure all computations for the current tile\n        // are complete before proceeding to load the next tile.\n        __syncthreads();\n    }\n\n    // Write the final computed Cvalue to the global memory output matrix C\n    // Ensure the write is within the bounds of C.\n    if (globalRow < N && globalCol < N) {\n        C[globalRow * N + globalCol] = Cvalue;\n    }\n}\n\"\"\"\n\n# Compile the CUDA kernel using torch.utils.cpp_extension.load_inline\n# This compilation happens once when the module is loaded.\ntry:\n    _matmul_cuda_module = load_inline(\n        name=\"matmul_tiled_kernel_module\",\n        cpp_sources=\"\",  # No C++ wrapper needed for direct kernel launch\n        cuda_sources=cuda_source,\n        functions=[\"matmul_tiled_kernel\"],  # Expose the kernel function\n        verbose=False,\n    )\nexcept Exception as e:\n    # In a production environment, proper error logging would be used.\n    # For this task, raising an error during ModelNew init is sufficient.\n    print(f\"Error compiling CUDA kernel: {e}\")\n    _matmul_cuda_module = None\n\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model that performs a single square matrix multiplication (C = A * B)\n    using a custom tiled CUDA kernel.\n    \"\"\"\n\n    def __init__(self):\n        super(ModelNew, self).__init__()\n        # Check if kernel compilation was successful\n        if _matmul_cuda_module is None:\n            raise RuntimeError(\n                \"CUDA kernel compilation failed during ModelNew initialization.\"\n            )\n        self.matmul_kernel = _matmul_cuda_module.matmul_tiled_kernel\n        self.TILE_SIZE = 32  # Must match the TILE_SIZE defined in the CUDA kernel\n\n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs the matrix multiplication using the custom CUDA kernel.\n\n        Args:\n            A (torch.Tensor): Input matrix A of shape (N, N).\n            B (torch.Tensor): Input matrix B of shape (N, N).\n\n        Returns:\n            torch.Tensor: Output matrix C of shape (N, N).\n        \"\"\"\n        # Input validation\n        if not A.is_cuda or not B.is_cuda:\n            raise ValueError(\"Inputs must be CUDA tensors.\")\n        if A.dtype != torch.float32 or B.dtype != torch.float32:\n            raise ValueError(\"Inputs must be float32 tensors.\")\n        if (\n            A.dim() != 2\n            or B.dim() != 2\n            or A.shape[0] != A.shape[1]\n            or B.shape[0] != B.shape[1]\n            or A.shape[0] != B.shape[0]\n        ):\n            raise ValueError(\"Inputs must be square matrices of the same size (N, N).\")\n\n        N = A.shape[0]\n\n        # Allocate output tensor C on the GPU\n        C = torch.empty_like(A)\n\n        # Calculate grid and block dimensions for kernel launch\n        # Each thread block computes a TILE_SIZE x TILE_SIZE tile of the output C.\n        # Use ceil division to ensure all elements are covered, even if N is not a multiple of TILE_SIZE.\n        grid_dim_x = (N + self.TILE_SIZE - 1) // self.TILE_SIZE\n        grid_dim_y = (N + self.TILE_SIZE - 1) // self.TILE_SIZE\n        grid_dim = (grid_dim_x, grid_dim_y)\n        block_dim = (self.TILE_SIZE, self.TILE_SIZE)\n\n        # Launch the custom CUDA kernel\n        # Arguments: (A_ptr, B_ptr, C_ptr, N)\n        self.matmul_kernel[grid_dim, block_dim](A, B, C, N)\n\n        return C"], "term_out": ["================================================================================COMPILATION FAILED================================================================================Error: builtins.TypeError\nload_inline() missing 1 required positional argument: 'cpp_sources'\nThe generated CUDA kernel failed to compile.Please check the kernel implementation for syntax errors,incorrect PyTorch CUDA extension API usage, or compilation issues.", "================================================================================CORRECTNESS CHECK FAILED================================================================================Runtime Error: builtins.RuntimeError\nCUDA kernel compilation failed during ModelNew initialization."], "analysis": ["Compilation failed. The CUDA kernel code has syntax or API errors. Error: builtins.TypeError. Review the error messages and fix the compilation issues.", "Runtime error during correctness testing. Error: builtins.RuntimeError. The kernel compiled but failed during execution. Check for memory access violations, synchronization issues, or invalid operations."], "exp_name": "26-lumpy-offbeat-porpoise", "metrics": [0, 0]}

let lastClick = 0;
let firstFrameTime = undefined;

let nodes = [];
let edges = [];

let lastScrollPos = 0;

setup = () => {
  canvas = createCanvas(...updateTargetDims());
};

class Node {
  x;
  y;
  size;
  xT;
  yT;
  xB;
  yB;
  treeInd;
  color;
  relSize;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  hasChildren = false;
  isRootNode = true;
  isStarred = false;
  selected = false;
  renderSize = 10;
  edges = [];
  bgCol;

  constructor(x, y, relSize, treeInd) {
    const minSize = 35;
    const maxSize = 60;

    const maxColor = 10;
    const minColor = 125;

    this.relSize = relSize;
    this.treeInd = treeInd;
    this.size = minSize + (maxSize - minSize) * relSize;
    this.color = minColor + (maxColor - minColor) * relSize;
    this.bgCol = Math.round(Math.max(this.color / 2, 0));

    this.x = x;
    this.y = y;
    this.xT = x;
    this.yT = y - this.size / 2;
    this.xB = x;
    this.yB = y + this.size / 2;

    nodes.push(this);
  }

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  child = (node) => {
    let edge = new Edge(this, node);
    this.edges.push(edge);
    edges.push(edge);
    this.hasChildren = true;
    node.isRootNode = false;
    return node;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    const mouseXlocalCoords = (mouseX - width / 2) / scaleFactor;
    const mouseYlocalCoords = (mouseY - height / 2) / scaleFactor;
    const isMouseOver =
      dist(mouseXlocalCoords, mouseYlocalCoords, this.x, this.y) <
      this.renderSize / 1.5;
    if (isMouseOver) cursor(HAND);
    if (isMouseOver && mouseIsPressed) {
      nodes.forEach((n) => (n.selected = false));
      this.selected = true;
      setCodeAndPlan(
        treeStructData.code[this.treeInd],
        treeStructData.plan[this.treeInd],
      );
      manualSelection = true;
    }

    this.renderSize = this.size;
    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
      } else {
        this.renderSize =
          this.size *
          (0.8 +
            0.2 *
              (-3.33 * this.animationProgress ** 2 +
                4.33 * this.animationProgress));
      }
    }

    fill(this.color);
    if (this.selected) {
      fill(accentCol);
    }

    noStroke();
    square(
      this.x - this.renderSize / 2,
      this.y - this.renderSize / 2,
      this.renderSize,
      10,
    );

    noStroke();
    textAlign(CENTER, CENTER);
    textSize(this.renderSize / 2);
    fill(255);
    // fill(lerpColor(color(accentCol), color(255), this.animationProgress))
    text("{ }", this.x, this.y - 1);
    // DEBUG PRINT:
    // text(round(this.relSize, 2), this.x, this.y - 1)
    // text(this.treeInd, this.x, this.y + 15)

    const dotAnimThreshold = 0.85;
    if (this.isStarred && this.animationProgress >= dotAnimThreshold) {
      let dotAnimProgress =
        (this.animationProgress - dotAnimThreshold) / (1 - dotAnimThreshold);
      textSize(
        ((-3.33 * dotAnimProgress ** 2 + 4.33 * dotAnimProgress) *
          this.renderSize) /
          2,
      );
      if (this.selected) {
        fill(0);
        stroke(0);
      } else {
        fill(accentCol);
        stroke(accentCol);
      }
      strokeWeight((-(dotAnimProgress ** 2) + dotAnimProgress) * 2);
      text("*", this.x + 20, this.y - 11);
      noStroke();
    }

    if (!this.isStatic) {
      fill(bgCol);
      const progressAnimBaseSize = this.renderSize + 5;
      rect(
        this.x - progressAnimBaseSize / 2,
        this.y -
          progressAnimBaseSize / 2 +
          progressAnimBaseSize * this.animationProgress,
        progressAnimBaseSize,
        progressAnimBaseSize * (1 - this.animationProgress),
      );
    }
    if (this.animationProgress >= 0.9) {
      this.edges
        .sort((a, b) => a.color() - b.color())
        .forEach((e, i) => {
          e.startAnimation((i / this.edges.length) ** 2 * 1000);
        });
    }
  };
}

class Edge {
  nodeT;
  nodeB;
  animX = 0;
  animY = 0;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  weight = 0;

  constructor(nodeT, nodeB) {
    this.nodeT = nodeT;
    this.nodeB = nodeB;
    this.weight = 2 + nodeB.relSize * 1;
  }

  color = () => this.nodeB.color;

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
        this.animX = this.nodeB.xT;
        this.animY = this.nodeB.yT;
      } else {
        this.animX = bezierPoint(
          this.nodeT.xB,
          this.nodeT.xB,
          this.nodeB.xT,
          this.nodeB.xT,
          this.animationProgress,
        );

        this.animY = bezierPoint(
          this.nodeT.yB,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          this.nodeB.yT,
          this.animationProgress,
        );
      }
    }
    if (this.animationProgress >= 0.97) {
      this.nodeB.startAnimation();
    }

    strokeWeight(this.weight);
    noFill();
    stroke(
      lerpColor(color(bgCol), color(accentCol), this.nodeB.relSize * 1 + 0.7),
    );
    bezier(
      this.nodeT.xB,
      this.nodeT.yB,
      this.nodeT.xB,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      this.animY,
    );
  };
}

draw = () => {
  cursor(ARROW);
  frameRate(120);
  if (!firstFrameTime && frameCount <= 1) {
    firstFrameTime = millis();
  }
  // ---- update global animation state ----
  const initialSpeedScalingEaseIO =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) * PI) + 1) / 2;
  const initialSpeedScalingEase =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) ** (1 / 2) * PI) + 1) / 2;
  const initAnimationSpeedFactor = 1.0 - 0.4 * initialSpeedScalingEaseIO;
  // update global scaling-aware clock
  globalTime += globalAnimSpeed * initAnimationSpeedFactor * deltaTime;

  if (nodes.length == 0) {
    const spacingHeight = height * 1.3;
    const spacingWidth = width * 1.3;
    treeStructData.layout.forEach((lay, index) => {
      new Node(
        spacingWidth * lay[0] - spacingWidth / 2,
        20 + spacingHeight * lay[1] - spacingHeight / 2,
        1 - treeStructData.metrics[index],
        index,
      );
    });
    treeStructData.edges.forEach((ind) => {
      nodes[ind[0]].child(nodes[ind[1]]);
    });
    nodes.forEach((n) => {
      if (n.isRootNode) n.startAnimation();
    });
    nodes[0].selected = true;
    setCodeAndPlan(
      treeStructData.code[0],
      treeStructData.plan[0],
    )
  }

  const staticNodes = nodes.filter(
    (n) => n.isStatic || n.animationProgress >= 0.7,
  );
  if (staticNodes.length > 0) {
    const largestNode = staticNodes.reduce((prev, current) =>
      prev.relSize > current.relSize ? prev : current,
    );
    if (!manualSelection) {
      if (!largestNode.selected) {
        setCodeAndPlan(
          treeStructData.code[largestNode.treeInd],
          treeStructData.plan[largestNode.treeInd],
        );
      }
      staticNodes.forEach((node) => {
        node.selected = node === largestNode;
      });
    }
  }
  background(bgCol);
  // global animation transforms
  translate(width / 2, height / 2);
  scale(scaleFactor);

  
  // ---- fg render ----
  edges.forEach((e) => e.render());
  nodes.forEach((n) => n.render());
  
};

    </script>
    <title>AIDE Run Visualization</title>
    <style>
      body,
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        overflow: scroll;
      }
      body {
        background-color: #f2f0e7;
      }
      canvas {
        float: left;
        height: 100vh;
        width: 40vw;
      }
      #text-container {
        float: right;
        height: 100vh;
        width: 50vw;
        background-color: #282c34;
      }
      #plan {
        /* border-left: 2px solid #282c34; */
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
      }
    </style>
  </head>
  <body>
    <pre
      id="text-container"
    ><div id="plan"></div><hr><code id="code" class="language-python"></code></pre>
  </body>
</html>
